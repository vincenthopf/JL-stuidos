<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Bare Ball Buster</title>
    <meta name="description" content="An action-packed arcade shooting game where you fight waves of enemies!">
    <meta name="theme-color" content="#1a1a2e">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Ball Buster">
    <link rel="shortcut icon" href="#" />
    <link rel="apple-touch-icon" href="icons/icon-192x192.png">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #fff;
            touch-action: none; /* Prevent browser handling of touch events */
        }
        canvas {
            border: none;
            box-shadow: none;
            border-radius: 0;
            background: linear-gradient(to bottom, #000000, #0a0a2a);
            position: absolute;
            top: 0;
            left: 0;
            /* Remove fixed width/height to prevent stretching */
            /* width: 100%; */
            /* height: 100%; */
        }
        #upgradeMenu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(1);
            background: rgba(20, 30, 60, 0.96);
            padding: 44px 36px 32px 36px;
            border-radius: 24px;
            border: 2.5px solid #7ecbffcc;
            box-shadow: 0 8px 48px 0 #7ecbff33, 0 1.5px 8px 0 rgba(0,0,0,0.18);
            display: none;
            z-index: 100;
            min-width: 340px;
            max-width: 95vw;
            max-height: 90vh;
            overflow-y: auto;
            animation: popIn 0.5s cubic-bezier(.68,-0.55,.27,1.55);
            backdrop-filter: blur(18px) saturate(1.2);
        }
        @keyframes popIn {
            0% { transform: translate(-50%, -50%) scale(0.8); opacity: 0; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }
        #upgradeOptions {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 18px;
            max-width: 600px;
        }
        .upgrade-button {
            background: linear-gradient(120deg, #1a1a4a 60%, #2a2a6a 100%);
            border: 2px solid #7ecbffcc;
            color: #fff;
            padding: 20px 0;
            margin: 0;
            cursor: pointer;
            border-radius: 14px;
            width: 240px;
            font-size: 1.15em;
            font-weight: 600;
            text-shadow: 0 0 10px #7ecbff55;
            box-shadow: 0 2px 12px 0 #7ecbff22;
            transition: all 0.18s cubic-bezier(.68,-0.55,.27,1.55);
            outline: none;
        }
        .upgrade-button:focus, .upgrade-button:hover {
            background: linear-gradient(120deg, #2a2a6a 60%, #7ecbff 100%);
            border: 2.5px solid #7ecbff;
            box-shadow: 0 0 24px 0 #7ecbffaa;
            color: #fff;
            transform: scale(1.08) translateY(-2px);
        }
        .upgrade-button:last-child {
            background: linear-gradient(120deg, #4a1a1a 60%, #6a2a2a 100%);
            border-color: #ff8888cc;
            color: #fff;
        }
        .upgrade-button:last-child:hover, .upgrade-button:last-child:focus {
            background: linear-gradient(120deg, #6a2a2a 60%, #ff8888 100%);
            border-color: #ff8888;
            box-shadow: 0 0 24px 0 #ff8888aa;
        }
        #waveSelectMenu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(1);
            background: rgba(20, 30, 60, 0.92);
            padding: 40px 36px 32px 36px;
            border-radius: 24px;
            border: 2.5px solid rgba(88, 161, 247, 0.7);
            box-shadow: 0 8px 48px 0 rgba(88, 161, 247, 0.25), 0 1.5px 8px 0 rgba(0,0,0,0.18);
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 100;
            min-width: 340px;
            max-width: 95vw;
            max-height: 90vh;
            overflow-y: auto;
            animation: popIn 0.5s cubic-bezier(.68,-0.55,.27,1.55);
            backdrop-filter: blur(18px) saturate(1.2);
        }
        @keyframes popIn {
            0% { transform: translate(-50%, -50%) scale(0.8); opacity: 0; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }
        .menu-title {
            color: #7ecbff;
            margin-bottom: 24px;
            text-align: center;
            font-size: 2.1em;
            letter-spacing: 1.5px;
            font-weight: 700;
            text-shadow: 0 2px 16px #1a1a4a44;
        }
        .wave-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(110px, 1fr));
            gap: 16px;
            margin: 18px 0 18px 0;
            width: 100%;
            justify-items: center;
        }
        .wave-button {
            background: linear-gradient(120deg, #1a1a4a 60%, #2a2a6a 100%);
            border: 2px solid rgba(88, 161, 247, 0.7);
            color: #fff;
            padding: 18px 0;
            cursor: pointer;
            border-radius: 12px;
            width: 110px;
            font-size: 1.1em;
            font-weight: 600;
            text-shadow: 0 0 10px rgba(88, 161, 247, 0.3);
            box-shadow: 0 2px 12px 0 rgba(88, 161, 247, 0.10);
            transition: all 0.18s cubic-bezier(.68,-0.55,.27,1.55);
            outline: none;
        }
        .wave-button.selected, .wave-button:focus, .wave-button:hover {
            background: linear-gradient(120deg, #2a2a6a 60%, #58A1F7 100%);
            border: 2.5px solid #58A1F7;
            box-shadow: 0 0 24px 0 #58A1F7aa;
            color: #fff;
            transform: scale(1.08) translateY(-2px);
        }
        .start-button {
            background: linear-gradient(90deg, #1a4a1a 60%, #2a6a2a 100%);
            border: 2px solid rgba(88, 247, 88, 0.7);
            color: #fff;
            padding: 16px 36px;
            margin-top: 18px;
            cursor: pointer;
            border-radius: 12px;
            font-size: 1.2em;
            font-weight: 700;
            text-shadow: 0 0 10px rgba(88, 247, 88, 0.4);
            box-shadow: 0 2px 12px 0 rgba(88, 247, 88, 0.10);
            transition: all 0.18s cubic-bezier(.68,-0.55,.27,1.55);
        }
        .start-button:hover, .start-button:focus {
            background: linear-gradient(90deg, #2a6a2a 60%, #7fff7f 100%);
            box-shadow: 0 0 24px 0 #7fff7faa;
            color: #fff;
            transform: scale(1.06) translateY(-2px);
        }
        
        #pauseMenu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            font-family: 'Arial', sans-serif;
            display: none; /* Hidden by default */
            z-index: 100; /* Ensure it's on top */
        }

        #pauseMenu h1 {
            margin-top: 0;
            font-size: 2.5em;
            color: #ffdd57; /* Yellowish color */
        }

        #pauseMenu p {
            font-size: 1.2em;
            color: #cccccc; /* Light gray */
        }
        /* Debug Panel Styles */
        #debugPanel {
            font-family: monospace;
            font-size: 12px;
        }
        #debugPanel .debug-item {
            margin-bottom: 4px;
            display: flex;
            justify-content: space-between;
        }
        #debugPanel .debug-key {
            color: #aaaaff;
            margin-right: 10px;
        }
        #debugPanel .debug-value {
            color: #ffffff;
        }
        #debugPanel .debug-section-header {
            margin-top: 10px;
            margin-bottom: 5px;
            color: #ffaaaa;
            font-weight: bold;
            border-bottom: 1px solid #444;
            padding-bottom: 3px;
        }
        #debugPanel .error-entry {
            margin-bottom: 8px;
            padding-bottom: 8px;
            border-bottom: 1px solid #444;
        }
        #debugPanel .error-message {
            color: #ff5555;
            font-weight: bold;
        }
        #debugPanel .error-location {
            color: #aaaaff;
            font-size: 10px;
        }
        #debugPanel .error-time, 
        #debugPanel .timestamp {
            color: #999;
            font-size: 10px;
        }
        #debugPanel .debug-controls {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
        }
        #debugPanel button {
            background: #333;
            color: white;
            border: 1px solid #555;
            padding: 3px 8px;
            cursor: pointer;
        }
        #debugPanel button:hover {
            background: #444;
        }
        #debugBtn {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0,0,0,0.5);
            color: #fff;
            padding: 6px 10px;
            font-size: 18px;
            cursor: pointer;
            z-index: 1000;
            border-radius: 5px;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 36px;
            height: 36px;
            box-shadow: 0 2px 8px 0 rgba(0,0,0,0.12);
        }
        #debugBtn:hover {
            background: rgba(30, 30, 80, 0.7) !important;
        }
        /* --- BEAUTIFUL, COMPACT GLASSY TOP-LEFT UI PANEL --- */
        #mainUIPanel {
            position: absolute;
            top: 24px;
            left: 24px;
            min-width: 220px;
            max-width: 320px;
            padding: 14px 18px 10px 18px;
            background: rgba(20, 28, 44, 0.82);
            border-radius: 16px;
            border: 1.5px solid #3a4a6a55;
            box-shadow: 0 4px 24px 0 #7ecbff18, 0 1.5px 8px 0 rgba(0,0,0,0.18);
            z-index: 10;
            backdrop-filter: blur(12px) saturate(1.1);
            display: flex;
            flex-direction: column;
            gap: 6px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #fff;
            pointer-events: none;
        }
        @media (max-width: 600px) {
            #mainUIPanel {
                left: 6px;
                top: 6px;
                min-width: 120px;
                max-width: 98vw;
                padding: 7px 4px 6px 4px;
            }
        }
        .main-ui-bar {
            width: 100%;
            height: 13px;
            background: rgba(30, 40, 70, 0.6);
            border-radius: 7px;
            margin-bottom: 4px;
            overflow: hidden;
            box-shadow: 0 1px 4px 0 #7ecbff18;
            position: relative;
            display: flex;
            align-items: center;
        }
        .main-ui-bar-fill {
            height: 100%;
            border-radius: 7px;
            transition: width 0.3s cubic-bezier(.68,-0.55,.27,1.55);
            box-shadow: 0 0 8px 0 #7ecbff33;
            position: absolute;
            left: 0; top: 0;
        }
        .main-ui-bar.health {
            background: rgba(40, 60, 40, 0.6);
        }
        .main-ui-bar-fill.health {
            background: linear-gradient(90deg, #7ecbff 0%, #58F77A 100%);
        }
        .main-ui-bar.energy {
            background: rgba(30, 40, 70, 0.6);
        }
        .main-ui-bar-fill.energy {
            background: linear-gradient(90deg, #58A1F7 0%, #7ecbff 100%);
        }
        .main-ui-bar-value {
            position: absolute;
            right: 10px;
            top: 0;
            height: 100%;
            display: flex;
            align-items: center;
            font-size: 0.98em;
            font-weight: 600;
            color: #fff;
            text-shadow: 0 1px 4px #0008;
            pointer-events: none;
        }
        .main-ui-row {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 2px;
            justify-content: space-between;
        }
        .main-ui-icon {
            font-size: 1.1em;
            margin-right: 2px;
        }
        .main-ui-value {
            font-size: 1em;
            font-weight: 600;
            color: #fff;
            text-shadow: 0 1px 4px #0008;
        }
        .main-ui-secondary {
            color: #b0cfff;
            font-size: 0.95em;
            margin-left: 2px;
        }
        .main-ui-timer {
            color: #b0cfff;
            font-size: 0.98em;
            text-align: right;
            margin-bottom: 2px;
        }
        .main-ui-powerups {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-top: 4px;
        }
        .main-ui-powerup-pill {
            display: flex;
            align-items: center;
            gap: 4px;
            background: rgba(60, 80, 120, 0.7);
            border-radius: 12px;
            padding: 2px 10px 2px 7px;
            font-size: 0.93em;
            color: #ffb347;
            font-weight: 500;
            box-shadow: 0 1px 4px #0002;
            border: 1px solid #ffb34733;
            min-width: 0;
        }
        .main-ui-powerup-pill-bar {
            height: 5px;
            width: 38px;
            background: rgba(255,255,255,0.10);
            border-radius: 3px;
            margin-left: 6px;
            overflow: hidden;
            flex-shrink: 0;
        }
        .main-ui-powerup-pill-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #ffb347 0%, #ff6a00 100%);
            border-radius: 3px;
            transition: width 0.3s cubic-bezier(.68,-0.55,.27,1.55);
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <!-- Pause Menu -->
    <div id="pauseMenu">
        <h1>Paused</h1>
        <p>Press 'P' to Resume</p>
    </div>

    <div id="upgradeMenu">
        <h2 style="text-align: center; margin-bottom: 20px; color: #58A1F7;">Wave Complete!</h2>
        <div id="upgradeOptions"></div>
    </div>
    <div id="waveSelectMenu">
        <h2 class="menu-title">Select Starting Wave</h2>
        <div class="wave-grid" id="waveButtons"></div>
        <button class="start-button" id="startGameButton">Start Game</button>
    </div>
    
    <!-- Debug and Error Panels -->
    <div id="errorDisplay" style="position: absolute; top: 0; left: 0; right: 0; background: rgba(255, 0, 0, 0.8); color: white; padding: 10px; font-family: monospace; font-size: 14px; z-index: 1000; max-height: 50vh; overflow-y: auto; display: none;"></div>
    
    <div id="debugPanel" style="position: absolute; bottom: 0; right: 0; background: rgba(0, 0, 0, 0.8); border: 1px solid #444; color: #fff; padding: 10px; font-family: monospace; font-size: 12px; z-index: 1000; width: 300px; max-height: 300px; overflow-y: auto; display: none;">
        <div class="debug-controls">
            <button id="debugClearBtn">Clear Log</button>
            <button id="debugToggleBtn">Toggle Debug</button>
        </div>
        <div id="debugContent"></div>
    </div>
    
    <div id="debugBtn" title="Show Debug Panel">🐞</div>
    
    <div id="mainUIPanel"></div>
    
    <script>
        // Add debugging and error handling functions
        function showError(message, error) {
            // Record error in the game errors array for the debug panel
            if (typeof recordError === 'function') {
                try {
                    recordError(message, error);
                } catch (e) {
                    console.error("Error recording error:", e);
                }
            } else {
                // If recordError not yet defined, store in window.gameErrors directly
                if (!window.gameErrors) window.gameErrors = [];
                window.gameErrors.push({
                    message: message,
                    error: error,
                    location: error && error.stack ? error.stack.split('\n')[1] : 'Unknown',
                    timestamp: Date.now()
                });
                // Keep at reasonable size
                if (window.gameErrors.length > 20) window.gameErrors.shift();
            }
            
            // Create error container if it doesn't exist
            let errorContainer = document.getElementById('errorContainer');
            if (!errorContainer) {
                errorContainer = document.createElement('div');
                errorContainer.id = 'errorContainer';
                errorContainer.style.position = 'fixed';
                errorContainer.style.bottom = '10px';
                errorContainer.style.right = '10px';
                errorContainer.style.maxWidth = '300px';
                errorContainer.style.backgroundColor = 'rgba(255, 0, 0, 0.8)';
                errorContainer.style.color = 'white';
                errorContainer.style.padding = '10px';
                errorContainer.style.borderRadius = '5px';
                errorContainer.style.fontFamily = 'monospace';
                errorContainer.style.fontSize = '12px';
                errorContainer.style.zIndex = '9999';
                errorContainer.style.maxHeight = '150px';
                errorContainer.style.overflow = 'auto';
                document.body.appendChild(errorContainer);
            }

            // Create error message
            const errorMessage = document.createElement('div');
            errorMessage.style.marginBottom = '5px';
            errorMessage.style.borderBottom = '1px solid rgba(255, 255, 255, 0.3)';
            errorMessage.style.paddingBottom = '5px';
            
            // Format the error message
            let errorText = `<strong>${message}</strong>`;
            if (error) {
                errorText += `<br>${error.message || error}`;
                if (error.stack) {
                    // Get the first line of the stack trace
                    const stackLine = error.stack.split('\n')[1];
                    if (stackLine) {
                        errorText += `<br><small>${stackLine.trim()}</small>`;
                    }
                }
            }
            
            errorMessage.innerHTML = errorText;
            
            // Add error to container
            errorContainer.appendChild(errorMessage);
            
            // Remove error after 5 seconds
            setTimeout(() => {
                if (errorMessage && errorMessage.parentNode === errorContainer) {
                    errorContainer.removeChild(errorMessage);
                }
                
                // Remove container if empty
                if (errorContainer.children.length === 0) {
                    document.body.removeChild(errorContainer);
                }
            }, 5000);
            
            // Also update error display element if it exists
            const errorDisplay = document.getElementById('errorDisplay');
            if (errorDisplay) {
                errorDisplay.style.display = 'block';
                errorDisplay.innerHTML += `<div>${errorText}</div>`;
                
                // Auto-hide after 10 seconds
                setTimeout(() => {
                    errorDisplay.style.display = 'none';
                    errorDisplay.innerHTML = '';
                }, 10000);
            }
            
            // Also log to console
            console.error(message, error);
        }

        // Add a safe wrapper for any function
        function safeExecute(func, funcName, ...args) {
            try {
                if (typeof func !== 'function') {
                    throw new Error(`${funcName} is not a function`);
                }
                return func(...args);
            } catch (error) {
                showError(`Error in ${funcName}`, error);
                return null;
            }
        }

        // Debug mode variables
        let debugMode = false;
        let frameTimeHistory = [];
        // reducedEffects is defined elsewhere in the code

        // Initialize debug tools
            window.functionExecutionTracker = {
                enabled: false,
                callStack: [],
                trackCall: function(functionName, args) {
                    if (!this.enabled) return;
                    this.callStack.push({
                        function: functionName,
                        args: args,
                        timestamp: Date.now()
                    });
                    // Keep stack at reasonable size
                    if (this.callStack.length > 100) {
                        this.callStack.shift();
                    }
                },
                getCallStack: function() {
                    return this.callStack;
                },
                clear: function() {
                    this.callStack = [];
                }
            };

        // Initialize debug breakpoints
            window.debugBreakpoints = {};

        // Set the document title
        document.title = "Bare Ball Buster";
        
        // Sound Manager
        const SoundManager = {
            audioContext: null,
            sounds: {}, // Stores { buffer: AudioBuffer }
            activeSources: {}, // Stores { source: AudioBufferSourceNode, gainNode: GainNode, volume: number } for pausable sounds
            masterVolume: 0.7, // Default volume
            soundsReady: false,
            pendingSounds: 0,
            // ambientPlaying: false, // Flag to track ambient music - Can be derived from activeSources now

            init() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    console.log("AudioContext initialized.");
                    // Resume context on user interaction
                    const resumeContext = () => {
                        if (this.audioContext.state === 'suspended') {
                            this.audioContext.resume().then(() => {
                                console.log("AudioContext resumed successfully.");
                                // Play ambient music once context is resumed and sounds are ready
                                // Check if already playing via isPlaying before starting
                                if (this.soundsReady && !this.isPlaying('AMBIENT')) {
                                    // Play looped (implicitly pausable) at 30% volume
                                    this.playSound('AMBIENT', 0.3, true); 
                                }
                                document.removeEventListener('click', resumeContext);
                                document.removeEventListener('keydown', resumeContext);
                            }).catch(e => console.error("Error resuming AudioContext:", e));
                        } else if (this.audioContext.state === 'running') {
                           // If context is already running, try playing ambient immediately if ready
                           if (this.soundsReady && !this.isPlaying('AMBIENT')) {
                               this.playSound('AMBIENT', 0.3, true);
                           }
                        }
                    };
                    document.addEventListener('click', resumeContext, { once: true });
                    document.addEventListener('keydown', resumeContext, { once: true });
                    
                } catch (e) {
                    console.error("Web Audio API is not supported in this browser", e);
                    showError("Web Audio API not supported", e);
                }
            },

            loadSound(name, url) {
                if (!this.audioContext) return Promise.reject("AudioContext not initialized");
                console.log(`Attempting to load sound: ${name} from ${url}`);
                this.pendingSounds++;
                return fetch(url)
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status} for ${url}`);
                        }
                        return response.arrayBuffer();
                    })
                    .then(arrayBuffer => this.audioContext.decodeAudioData(arrayBuffer))
                    .then(audioBuffer => {
                        this.sounds[name] = { buffer: audioBuffer };
                        console.log(`Sound loaded: ${name.toUpperCase()}`);
                        this.pendingSounds--;
                        if (this.pendingSounds === 0) {
                           this.soundsReady = true;
                           console.log("Sounds ready!");
                        }
                    })
                    .catch(error => {
                        console.error(`Error loading sound ${name} from ${url}:`, error);
                        showError(`Error loading sound ${name}`, error);
                        this.pendingSounds--; // Decrement even on error
                        // Optionally re-check if sounds are ready if others might still load
                        if (this.pendingSounds === 0) { 
                           this.soundsReady = true;
                           console.log("Sounds ready! (despite errors)");
                        }
                    });
            },

            playSound(name, volume = 1, loop = false, pausable = false) { // Add pausable flag
                console.log(`Attempting to play sound: ${name.toUpperCase()}`);
                if (!this.audioContext || !this.sounds[name] || !this.sounds[name].buffer || !this.soundsReady) {
                    console.warn(`Cannot play sound: ${name}. Context: ${!!this.audioContext}, Sound loaded: ${!!this.sounds[name]}, Buffer: ${!!this.sounds[name]?.buffer}, Ready: ${this.soundsReady}`);
                    return null; // Return null if sound cannot be played
                }
                if (this.audioContext.state === 'suspended') {
                    console.warn("AudioContext suspended. Cannot play sound until user interaction.");
                    return null;
                }

                try {
                    const source = this.audioContext.createBufferSource();
                    const gainNode = this.audioContext.createGain();
                    const calculatedVolume = this.masterVolume * volume;

                    source.buffer = this.sounds[name].buffer;
                    source.loop = loop;

                    source.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);

                    gainNode.gain.setValueAtTime(calculatedVolume, this.audioContext.currentTime);

                    source.start(0);
                    console.log(`Sound played successfully: ${name.toUpperCase()}`);

                    // If pausable, store references
                    if (pausable || loop) { // Store looped sounds by default as they often need control
                        // If this sound is already playing pausable, stop the old one first
                        if (this.activeSources[name]) {
                            try {
                                this.activeSources[name].source.stop();
                            } catch (e) { /* Might already be stopped */ }
                        }
                        this.activeSources[name] = { source, gainNode, volume: calculatedVolume };
                        
                        // Clean up when the sound naturally ends (if not looping)
                        if (!loop) {
                            source.onended = () => {
                                if (this.activeSources[name] && this.activeSources[name].source === source) {
                                    delete this.activeSources[name];
                                    console.log(`Cleaned up source for non-looping sound: ${name}`);
                                }
                            };
                        }
                    }
                    return { source, gainNode }; // Return nodes for potential external control
                } catch (e) {
                    console.error(`Error playing sound ${name}:`, e);
                    showError(`Error playing sound ${name}`, e);
                    return null;
                }
            },
            
            // New method to pause a specific tracked sound
            pauseSound(name) {
                const active = this.activeSources[name];
                if (active && active.gainNode) {
                    try {
                        // Store current volume before pausing (optional, using stored volume)
                        // active.originalVolume = active.gainNode.gain.value;
                        active.gainNode.gain.setValueAtTime(0, this.audioContext.currentTime); // Set gain to 0
                        console.log(`Paused sound: ${name}`);
                    } catch (e) {
                        console.error(`Error pausing sound ${name}:`, e);
                    }
                } else {
                    console.warn(`Cannot pause sound: ${name}. Not actively tracked or no gain node.`);
                }
            },
            
            // New method to resume a specific tracked sound
            resumeSound(name) {
                const active = this.activeSources[name];
                if (active && active.gainNode) {
                    try {
                        // Restore the original volume
                        const targetVolume = active.volume !== undefined ? active.volume : this.masterVolume; // Use stored volume or default
                        active.gainNode.gain.setValueAtTime(targetVolume, this.audioContext.currentTime);
                        console.log(`Resumed sound: ${name}`);
                    } catch (e) {
                        console.error(`Error resuming sound ${name}:`, e);
                    }
                } else {
                    console.warn(`Cannot resume sound: ${name}. Not actively tracked or no gain node.`);
                }
            },

            // Optional: Method to stop a specific sound completely
            stopSound(name) {
                 const active = this.activeSources[name];
                 if (active && active.source) {
                     try {
                         active.source.stop(0);
                         delete this.activeSources[name];
                         console.log(`Stopped sound: ${name}`);
                     } catch (e) {
                         console.error(`Error stopping sound ${name}:`, e);
                         // Clean up ref even if stop fails (might already be stopped)
                         delete this.activeSources[name]; 
                     }
                 } else {
                    console.warn(`Cannot stop sound: ${name}. Not actively tracked.`);
                 }
            },

            // Checks if a specific pausable sound is currently playing
            isPlaying(name) {
                return !!this.activeSources[name];
            },

            setMasterVolume(volume) {
                this.masterVolume = Math.max(0, Math.min(1, volume));
                console.log(`Master volume set to: ${this.masterVolume}`);
            },
            
            preloadSounds() {
                if (!this.audioContext) this.init(); // Ensure context is initialized
                if (!this.audioContext) return; // Exit if context failed to initialize
                
                console.log("Preloading all sounds...");
                this.ambientPlaying = false; // Reset flag on preload
                const soundFiles = {
                    'SHOOT': 'sounds/player shoot.mp3',
                    'PLAYER_HIT': 'sounds/getting damaged-[AudioTrimmer.com].wav',
                    'POWERUP_COLLECT': 'sounds/gain power-up.wav',
                    'SHIELD_HIT': 'sounds/sheild brakes-[AudioTrimmer.com].wav', // Corrected filename?
                    'AMBIENT': 'sounds/ambient music.wav' // Add ambient music
                    // Add other sounds here
                };

                const promises = Object.entries(soundFiles).map(([name, url]) => 
                    this.loadSound(name, url)
                );
                
                Promise.allSettled(promises).then(() => {
                     console.log("All sounds preloaded (or attempted).");
                     // Note: soundsReady flag is set within loadSound when pendingSounds reaches 0
                     // Removed ambient music start from here - moved to resumeContext
                });
            }
        };

        // Initialize Sound Manager and Preload Sounds
        SoundManager.preloadSounds();
        
        // Initialize canvas
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Set canvas to full screen size
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // Handle window resize
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            // Reset player position when screen resizes
            if (!gameState.gameOver && !gameState.gameWon) {
                gameState.player.x = canvas.width / 2;
                gameState.player.y = canvas.height / 2;
            }
        });

        // Game constants
        const CONSTANTS = {
            PLAYER: {
                BASE_SIZE: 40,
                BASE_SPEED: 5,
                BASE_HEALTH: 100,
                BASE_ENERGY: 100,
                ENERGY_REGEN: 0.4,
                SHOOT_COOLDOWN: 45,
                RAPID_FIRE_COOLDOWN: 5, // No longer used - kept for compatibility
                SHOOT_COST: 20,
                DASH_COOLDOWN: 30,
                DASH_DISTANCE: 100
            },
            BULLET: {
                SIZE: 8,
                SPEED: 10,
                LIFETIME: 60
            },
            POWER_UPS: {
                SIZE: 20,
                SPAWN_CHANCE: 0.01,  // Increased from 0.003 to 0.01 for more frequent power-up spawns
                DURATION: 300,
                MAX_COUNT: 3  // Maximum number of power-ups allowed at once
            },
            OBSTACLES: {
                SIZE: 200,  // Length of the wall
                THICKNESS: 20,  // Thickness of the wall
                SPAWN_CHANCE: 0.003,
                TYPES: ['WALL', 'CRYSTAL_WALL', 'BARRIER_WALL'],
                DAMAGE: 0,
                MAX_COUNT: 5,  // Reduced from 10 to 5 to improve performance
                LIFETIME: 1800,  // 30 seconds at 60fps
                RESPAWN_DELAY: 60  // 1 second delay before respawning
            },
            PLAYER_SPEED: 5,
            PLAYER_SIZE: 30,
            BULLET_SPEED: 10,
            BULLET_SIZE: 5,
            ENEMY_SIZE: 30,
            WAVE_DELAY: 2000,
            POWERUP_SIZE: 20,
            POWERUP_DURATION: 5000,
            FLOATING_TEXT_DURATION: 1500,
            FLOATING_TEXT_SPEED: 2,
            FLOATING_TEXT_SIZE: '24px'
        };

        // Visual constants
        const COLORS = {
            // Reverting Player and Bullet colors to previous state
            PLAYER: {
                CORE: '#58A1F7', // Original blue
                GLOW: '#1E90FF',
                TRAIL: 'rgba(88, 161, 247, 0.3)',
                SHIELD: 'rgba(0, 180, 255, 0.4)' // Keep shield color
            },
            BULLET: {
                CORE: '#FFD700', // Original yellow/gold
                GLOW: '#FFA500'
            },
            POWER_UPS: {
                RAPID_FIRE: '#00FF7F', // SpringGreen
                SHIELD: '#1E90FF', // DodgerBlue
                MULTI_SHOT: '#FF4500', // OrangeRed
                SPEED_BOOST: '#FFFF00', // Yellow
                HEALTH_RESTORE: '#FF69B4', // HotPink
                TIME_WARP: '#9932CC' // DarkOrchid
            },
            OBSTACLES: {
                // New vibrant colors
                WALL: { CORE: '#3a0ca3', GLOW: '#7b2cbf' },     // Deep Purple core, lighter Purple glow
                CRYSTAL_WALL: { CORE: '#0077b6', GLOW: '#48cae4' }, // Ocean Blue core, Cyan glow
                BARRIER_WALL: { CORE: '#1b4332', GLOW: '#52b788' }  // Forest Green core, Mint glow
            },
            ENEMY: {
                 // Reverting original enemies to previous colors
                NORMAL: { CORE: '#FF0000', GLOW: '#8B0000' }, // Red
                FAST: { CORE: '#FF8C00', GLOW: '#D2691E' }, // DarkOrange
                TANK: { CORE: '#8B0000', GLOW: '#4A0000' }, // DarkRed
                SHOOTER: { CORE: '#9370DB', GLOW: '#483D8B' }, // MediumPurple
                BOMBER: { CORE: '#32CD32', GLOW: '#006400' }, // LimeGreen (Keeping this one as it was green before)
                ELITE: { CORE: '#FFD700', GLOW: '#B8860B' }, // Gold
                // Keeping new enemy colors
                HEALER: { CORE: '#32CD32', GLOW: '#90EE90' }, // LimeGreen core, LightGreen glow
                MINELAYER: { CORE: '#A0522D', GLOW: '#CD853F' }, // Sienna core, Peru glow
                TURRET: { CORE: '#4682B4', GLOW: '#B0C4DE' }, // SteelBlue core, LightSteelBlue glow
                SPLITTER: { CORE: '#D2691E', GLOW: '#F4A460' }, // Chocolate core, SandyBrown glow
                BOSS: { CORE: '#FF00FF', GLOW: '#8B008B' } // Magenta
            },
            // Add Mine colors
            MINE: { 
                ARMING: '#FFA500', // Orange while arming
                ARMED: '#DC143C', // Crimson when armed
                GLOW: '#FF0000' // Red glow
            }
        };

        // Initialize game state
        let gameState = {
            player: {
                x: window.innerWidth / 2,
                y: window.innerHeight / 2,
                speed: CONSTANTS.PLAYER.BASE_SPEED,
                health: CONSTANTS.PLAYER.BASE_HEALTH,
                maxHealth: CONSTANTS.PLAYER.BASE_HEALTH,
                score: 0,
                bullets: [],
                dashCooldown: 0,
                shootCooldown: 0,
                energy: CONSTANTS.PLAYER.BASE_ENERGY,
                maxEnergy: CONSTANTS.PLAYER.BASE_ENERGY,
                trail: [],
                powerUps: [],
                shield: 0,
                multiShot: false,
                rapidFire: false,
                speedBoostActive: false,
                timeWarpActive: false,
                stuckCounter: 0, // Add stuckCounter to prevent undefined errors
                velocity: { x: 0, y: 0 }, // Restored velocity property
                level: {
                    damage: 1,
                    speed: 1,
                    health: 1,
                    energy: 1
                },
                powerUpDurationMultiplier: 1, // Initialize power-up duration multiplier
                radialBurstCooldown: 0, // Initialize to prevent undefined errors
                radialBurstRegenPenalty: 0 // Initialize to prevent undefined errors
            },
            enemies: [],
            powerUps: [],
            obstacles: [],
            currentWave: 1,
            wavesTotal: 10,
            enemiesPerWave: 10,
            enemiesDefeated: 0,
            waveComplete: false,
            gameOver: false,
            gameWon: false,
            keys: {},
            mousePos: { x: 0, y: 0 },
            mouseDown: false,
            particles: [],
            enemyBullets: [],
            selectedWave: 1,
            gameStarted: false,
            lastKeyPress: {},
            isBossFight: false,
            bossDefeated: false,
            healthRestoredTime: 0,
            floatingTexts: [],
            timeWarpActive: false,
            justDefeatedBoss: false, // Flag to prevent double wave increment
            // Track power-up durations
            activePowerUps: {
                shield: { active: false, remaining: 0, total: 0 },
                multiShot: { active: false, remaining: 0, total: 5000 },
                speedBoost: { active: false, remaining: 0, total: 7000 },
                rapidFire: { active: false, remaining: 0, total: 10000 }, // Set to 10 seconds exactly
                timeWarp: { active: false, remaining: 0, total: 5000 }
            },
            gameTimer: 0, // Add timer to track gameplay duration
            mines: [], // <<< Add mines array
            isPaused: false // <<< Add pause state here
        };

        // Secret code sequence tracking
        let secretCodeBuffer = [];
        let secretCodeTimeout = null;

        // Star field
        const stars = Array(300).fill().map(() => ({
            x: Math.random() * window.innerWidth,
            y: Math.random() * window.innerHeight,
            size: Math.random() * 2,
            speed: 0.1 + Math.random() * 0.5
        }));

        // Create a robust keyboard controller to handle key states
        const KeyboardController = {
            // Internal state
            _keys: {},
            _timestamps: {},
            _movementKeys: ['w', 'a', 's', 'd', 'arrowup', 'arrowdown', 'arrowleft', 'arrowright'],
            _waveSelectBuffer: [], // Stores { key: string, time: number } for K or L
            _waveSelectTimeout: null, // Timeout for the K+L sequence
            
            // Initialize controller
            init() {
                // Set up event listeners
                document.addEventListener('keydown', this.handleKeyDown.bind(this));
                document.addEventListener('keyup', this.handleKeyUp.bind(this));
                window.addEventListener('blur', this.handleBlur.bind(this));
                
                // Set up timer to check for stuck keys (every 3 seconds)
                setInterval(() => {
                    this.checkStuckKeys();
                }, 3000);
            },
            
            // Handle key down events
            handleKeyDown(e) {
                const key = e.key.toLowerCase();
                this._keys[key] = true;
                this._timestamps[key] = Date.now();

                // Toggle Pause with 'P' key (when game is started and not over)
                if (key === 'p' && gameState.gameStarted && !gameState.gameOver && !gameState.gameWon) {
                    // console.log("'P' key pressed, toggling pause."); // DEBUG REMOVED
                    gameState.isPaused = !gameState.isPaused;
                    const pauseMenu = document.getElementById('pauseMenu');
                    // console.log("Pause menu element:", pauseMenu); // DEBUG REMOVED
                    if (pauseMenu) { // Check if element exists before trying to set style
                        if (gameState.isPaused) {
                            // console.log("Setting pause menu display to block"); // DEBUG REMOVED
                            pauseMenu.style.display = 'block'; // Show pause menu
                            // Pause ambient sound using the new method
                            if (typeof SoundManager !== 'undefined') {
                                SoundManager.pauseSound('AMBIENT');
                            }
                        } else {
                            // console.log("Setting pause menu display to none"); // DEBUG REMOVED
                            pauseMenu.style.display = 'none'; // Hide pause menu
                            // Resume ambient sound using the new method
                            if (typeof SoundManager !== 'undefined') {
                                SoundManager.resumeSound('AMBIENT');
                            }
                            // Reset lastTime to prevent simulation jumps after unpausing
                            if (typeof lastTime !== 'undefined') {
                                lastTime = performance.now(); 
                            }
                        }
                    } else {
                        // console.error("Could not find pauseMenu element!"); // DEBUG REMOVED
                        // Still log error if menu element is missing
                        console.error("Could not find pauseMenu element!"); 
                    }
                    e.preventDefault(); // Prevent default 'p' behavior (like printing)
                    return; // Stop further processing for 'p'
                }
                
                // --- START K+L Wave Select Logic ---
                const waveSelectKeyTimeoutDuration = 1000; // ms to press the sequence
                const now = Date.now();
                let waveSelectTriggered = false;
                
                // Add key to sequence buffer if it's K or L
                if (key === 'k' || key === 'l') {
                    // Clear previous timeout if a new relevant key is pressed
                    if (this._waveSelectTimeout) {
                        clearTimeout(this._waveSelectTimeout);
                        this._waveSelectTimeout = null;
                    }
                    
                    // Add the keypress with timestamp
                    this._waveSelectBuffer.push({ key: key, time: now });
                    
                    // Prune buffer: remove keys older than the timeout duration
                    this._waveSelectBuffer = this._waveSelectBuffer.filter(entry => now - entry.time < waveSelectKeyTimeoutDuration);

                    // Check if both K and L are present in the recent buffer
                    const hasK = this._waveSelectBuffer.some(entry => entry.key === 'k');
                    const hasL = this._waveSelectBuffer.some(entry => entry.key === 'l');
                    
                    if (hasK && hasL) {
                        console.log("K+L sequence detected!"); // DEBUG
                        waveSelectTriggered = true;
                        // Show wave selection menu and pause game
                        gameState.gameStarted = false;
                        gameState.isPaused = true; // Ensure game is paused when menu shows
                        const waveMenu = document.getElementById('waveSelectMenu');
                        if (waveMenu) {
                            waveMenu.style.display = 'flex';
                            initWaveSelectionMenu(); // Re-initialize menu content
                        } else {
                            console.error("Could not find waveSelectMenu element!");
                        }
                        this._waveSelectBuffer = []; // Clear buffer after activation
                    } else if (this._waveSelectBuffer.length > 0) {
                        // If only one key is pressed, set a timeout to clear the buffer
                         this._waveSelectTimeout = setTimeout(() => {
                            // console.log("Clearing wave select buffer due to timeout"); // DEBUG
                            this._waveSelectBuffer = [];
                            this._waveSelectTimeout = null;
                        }, waveSelectKeyTimeoutDuration);
                    }
                }
                // --- END K+L Wave Select Logic ---
                
                // If wave select was triggered, stop processing other keys for this event
                if (waveSelectTriggered) {
                    return;
                }

                /* --- REMOVE OLD Shift+P+/ Logic --- */
                /*
                // Secret code sequence tracking (Shift+P+/)
                if (this._secretCodeTimeout) {
                    clearTimeout(this._secretCodeTimeout);
                }
                // Add key to sequence buffer
                if (e.shiftKey && key === 'p') {
                    this._secretCodeBuffer.push('shift+p');
                } else if (key === '/') {
                    this._secretCodeBuffer.push('/');
                }
                // Check for the full sequence
                if (this._secretCodeBuffer.length >= 2 && 
                    this._secretCodeBuffer.includes('shift+p') && 
                    this._secretCodeBuffer.includes('/')) {
                    // Show wave selection menu and pause game
                    gameState.gameStarted = false;
                    gameState.isPaused = true;
                    document.getElementById('waveSelectMenu').style.display = 'flex';
                    initWaveSelectionMenu();
                    this._secretCodeBuffer = []; // Clear buffer after activation
                    return;
                }
                // Set timeout to clear buffer after 1 second
                this._secretCodeTimeout = setTimeout(() => {
                    this._secretCodeBuffer = [];
                }, 1000);
                */
                 /* --- END REMOVED OLD LOGIC --- */
                
                // Restart game on 'r' key when game is over
                if (key === 'r' && (gameState.gameOver || gameState.gameWon)) {
                    restartGame();
                }
                
                // Dash on space key
                if (key === ' ' && gameState.player.dashCooldown <= 0 && gameState.player.energy >= 30) {
                    dash();
                }

                // In handleKeyDown, after dash logic:
                if (key === 'e' && gameState.player.energy >= gameState.player.maxEnergy && !gameState.player.radialBurstCooldown) {
                    shootRadialBurst();
                }
            },
            
            // Handle key up events
            handleKeyUp(e) {
                const key = e.key.toLowerCase();
                this._keys[key] = false;
                delete this._timestamps[key];
            },
            
            // Handle window blur (tab change, etc.)
            handleBlur() {
                // Clear all key states when window loses focus
                this._keys = {};
                this._timestamps = {};
            },
            
            // Check for stuck keys
            checkStuckKeys() {
                const now = Date.now();
                for (const key in this._timestamps) {
                    // If key has been pressed for more than 2 seconds
                    if (now - this._timestamps[key] > 2000) {
                        // Only reset non-movement keys if they're stuck
                        if (!this._movementKeys.includes(key)) {
                            this._keys[key] = false;
                            delete this._timestamps[key];
                        }
                    }
                }
            },
            
            // Reset all keys
            resetAllKeys() {
                this._keys = {};
                this._timestamps = {};
            },
            
            // Get current state of a key
            isKeyDown(key) {
                return !!this._keys[key.toLowerCase()];
            },
            
            // Update the gameState keys to match the controller
            updateGameState(gameState) {
                // Keep existing keys as is, only update with new ones
                if (!gameState.keys) {
                    gameState.keys = {};
                }
                
                // Copy all key states to gameState
                for (const key in this._keys) {
                    gameState.keys[key] = this._keys[key];
                }
                
                // For backward compatibility, update lastKeyPress
                if (!gameState.lastKeyPress) {
                    gameState.lastKeyPress = {};
                }
                
                for (const key in this._timestamps) {
                    gameState.lastKeyPress[key] = this._timestamps[key];
                }
            }
        };
        
        // Initialize the keyboard controller
        KeyboardController.init();

        // Initialize wave selection menu
        function initWaveSelectionMenu() {
            const waveButtons = document.getElementById('waveButtons');
            waveButtons.innerHTML = '';
            
            // Create a button for each available wave
            for (let i = 1; i <= gameState.wavesTotal; i++) {
                const button = document.createElement('button');
                button.className = 'wave-button';
                button.textContent = `Wave ${i}`;
                button.dataset.wave = i;
                
                // Highlight the currently selected wave
                if (i === gameState.selectedWave) {
                    button.classList.add('selected');
                }
                
                button.addEventListener('click', () => {
                    // Update selected wave
                    gameState.selectedWave = i;
                    
                    // Update button styles
                    document.querySelectorAll('.wave-button').forEach(btn => {
                        btn.classList.remove('selected');
                    });
                    
                    button.classList.add('selected');
                });
                
                waveButtons.appendChild(button);
            }
            
            // Add event listener to start button
            document.getElementById('startGameButton').addEventListener('click', startGameWithSelectedWave);
        }
        
        function startGameWithSelectedWave() {
            // Hide the menu
            document.getElementById('waveSelectMenu').style.display = 'none';
            
            // Set up game state for the selected wave
            gameState.currentWave = gameState.selectedWave;
            gameState.enemiesDefeated = 0;
            gameState.waveComplete = false;
            
            // Reset game timer when starting a new game
            gameState.gameTimer = 0;
            
            // Adjust difficulty based on wave - make early waves easier
            if (gameState.currentWave <= 3) {
                // Easier early waves (1-3)
                gameState.enemiesPerWave = 8 + (gameState.currentWave - 1) * 1;
            } else {
                // Normal difficulty progression for later waves
                gameState.enemiesPerWave = 10 + (gameState.currentWave - 1) * 2;
            }
            
            // Scale player based on wave (to simulate upgrade progress)
            if (gameState.currentWave > 1) {
                const upgradePoints = gameState.currentWave - 1;
                
                // Distribute upgrade points
                gameState.player.level.damage += upgradePoints * 0.2;
                gameState.player.level.speed += upgradePoints * 0.1;
                gameState.player.maxHealth += upgradePoints * 10;
                gameState.player.health = gameState.player.maxHealth;
                gameState.player.maxEnergy += upgradePoints * 5;
                gameState.player.energy = gameState.player.maxEnergy;
                gameState.player.speed += upgradePoints * 0.2;
            }
            
            // Mark game as started
            gameState.gameStarted = true;
            gameState.isPaused = false; // Use gameState.isPaused
        }
        
        // Show wave selection menu on load - change to not show by default
        window.addEventListener('load', () => {
            initWaveSelectionMenu();
            
            // Start game immediately at wave 1 instead of showing menu
            gameState.selectedWave = 1;
            gameState.gameStarted = true;
            gameState.isPaused = false; // Use gameState.isPaused
            document.getElementById('waveSelectMenu').style.display = 'none';
        });

        canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                gameState.mousePos.x = e.clientX - rect.left;
                gameState.mousePos.y = e.clientY - rect.top;
        });
        canvas.addEventListener('mousedown', () => gameState.mouseDown = true);
        canvas.addEventListener('mouseup', () => gameState.mouseDown = false);

        // Utility functions
        function createParticle(x, y, color, speed, size, lifetime, glow = false) {
            const angle = Math.random() * Math.PI * 2;
            return {
                x,
                y,
                dx: Math.cos(angle) * speed * (0.5 + Math.random()),
                dy: Math.sin(angle) * speed * (0.5 + Math.random()),
                size: size * (0.5 + Math.random()),
                color,
                glow,
                lifetime: lifetime * (0.8 + Math.random() * 0.4),
                alpha: 1
            };
        }

        function drawGlow(x, y, radius, color) {
                // Skip glow effects for off-screen elements
                if (x < -radius || x > canvas.width + radius || 
                    y < -radius || y > canvas.height + radius) {
                    return;
                }
                
                // Reduce the quality of glow effects for better performance
                radius = Math.min(radius, 100); // Cap maximum radius
                
                    const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
            gradient.addColorStop(0, color);
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(x - radius, y - radius, radius * 2, radius * 2);
        }

        // Game update functions
        function updateGame() {
            // Update all game elements
            updateStars();
            updatePlayer();
            updateBullets();
            updateEnemyBullets();
            updateEnemies();
            updatePowerUps();
            updateObstacles();
            updateParticles();
            updateFloatingTexts(); // Update floating text
            updateMines(); // <<< Call updateMines
            
            // Emergency check to prevent enemies from phasing through walls
            preventEnemyPhasing();
            
            // Spawn enemies if not in a boss fight
            if (!gameState.waveComplete && 
                !gameState.isBossFight && 
                gameState.enemies.length < (gameState.currentWave <= 5 ? 5 : 8) && // Wave-based enemy cap (5 for 1-5, 8 for 6+)
                gameState.enemiesDefeated < gameState.enemiesPerWave) { 
                if (Math.random() < 0.08) { // Increased spawn chance from 0.02 to 0.08 (8%)
                    spawnEnemy();
                }
            }
                
                // Check if wave is complete
            checkWaveComplete();
        }
        
        // Function to prevent enemies from phasing through walls
        function preventEnemyPhasing() {
            // Use a larger check distance to catch enemies BEFORE they phase through
            const checkDistance = 250;
            
            gameState.enemies.forEach(enemy => {
                // Check ALL obstacles for potential collision
                for (let obstacle of gameState.obstacles) {
                    // Skip check for dead enemies
                    if (enemy.health <= 0) continue;
                    
                    const dx = enemy.x - obstacle.x;
                    const dy = enemy.y - obstacle.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    
                    // Check walls that are close to enemy with a wider radius
                    if (dist > checkDistance) continue;
                    
                    // Use a much more aggressive detection radius
                    const extraDetectionBuffer = 10; // Increased from 0
                    
                    // Check if enemy is inside or very close to wall
                    let isInWall = false;
                    
                    if (obstacle.isHorizontal) {
                        // For horizontal walls, dx uses SIZE (length) and dy uses THICKNESS (width)
                        if (Math.abs(dy) < enemy.size + CONSTANTS.OBSTACLES.THICKNESS/2 + extraDetectionBuffer &&
                            Math.abs(dx) < CONSTANTS.OBSTACLES.SIZE/2 + extraDetectionBuffer) {
                            isInWall = true;
                        }
                    } else {
                        // For vertical walls, dy uses SIZE (length) and dx uses THICKNESS (width)
                        if (Math.abs(dx) < enemy.size + CONSTANTS.OBSTACLES.THICKNESS/2 + extraDetectionBuffer &&
                            Math.abs(dy) < CONSTANTS.OBSTACLES.SIZE/2 + extraDetectionBuffer) {
                            isInWall = true;
                        }
                    }
                    
                    if (isInWall) {
                        // Push enemy out with much stronger force
                        const norm = Math.max(0.1, Math.sqrt(dx*dx + dy*dy));
                        const pushX = (dx / norm) * 30; // Doubled push force from 15 to 30
                        const pushY = (dy / norm) * 30;
                        
                        // Move enemy out of wall with a significant push
                        enemy.x = enemy.x + pushX;
                        enemy.y = enemy.y + pushY;
                        
                        // Keep in bounds
                        enemy.x = Math.max(enemy.size, Math.min(canvas.width - enemy.size, enemy.x));
                        enemy.y = Math.max(enemy.size, Math.min(canvas.height - enemy.size, enemy.y));
                        
                        // Create a more noticeable "pop" effect to visualize the correction
                        for (let i = 0; i < 5; i++) { // Increased from 3 to 5 particles
                            gameState.particles.push(createParticle(
                                enemy.x, enemy.y,
                                '#FFFFFF',
                                3, 4, 15, // Larger, longer-lasting particles
                                true
                            ));
                        }
                        
                        // Temporarily slow down the enemy after a collision to prevent immediately trying to go through wall again
                        enemy.tempSlowdown = 15; // Frames to apply slowdown
                        
                        break; // Only handle one wall collision at a time
                    }
                }
                
                // Apply temporary slowdown if active
                if (enemy.tempSlowdown > 0) {
                    enemy.tempSlowdown--;
                    // We'll handle this in the enemy movement logic
                }
            });
        }

        function updatePlayer() {
            const player = gameState.player;
            
            // Store previous position to detect if player is actually moving
            const prevX = player.x;
            const prevY = player.y;

            // Sync keyboard controller state with gameState for compatibility
            KeyboardController.updateGameState(gameState);
            
            // Decrement cooldowns
            if (player.dashCooldown > 0) player.dashCooldown--;
            
            // Update health restored indicator
            if (gameState.healthRestoredTime > 0) {
                gameState.healthRestoredTime--;
            }
            
            // Simple cooldown decrease - rapid fire effect now handled in shooting function
            if (player.shootCooldown > 0) {
                player.shootCooldown--;
            }

            // Movement with improved handling
            let moveX = 0, moveY = 0;
            
            // Check for WASD or arrow keys using the controller
            if (KeyboardController.isKeyDown('w') || KeyboardController.isKeyDown('arrowup')) moveY -= 1;
            if (KeyboardController.isKeyDown('s') || KeyboardController.isKeyDown('arrowdown')) moveY += 1;
            if (KeyboardController.isKeyDown('a') || KeyboardController.isKeyDown('arrowleft')) moveX -= 1;
            if (KeyboardController.isKeyDown('d') || KeyboardController.isKeyDown('arrowright')) moveX += 1;
            
            // Normalize diagonal movement to prevent faster diagonal speed
            if (moveX !== 0 && moveY !== 0) {
                const norm = Math.sqrt(moveX * moveX + moveY * moveY);
                moveX /= norm;
                moveY /= norm;
            }
            
            // Update velocity for spider leg animation
            const targetVelocityX = moveX * player.speed;
            const targetVelocityY = moveY * player.speed;
            const velocityLerp = 0.3; // Smoothing factor

            player.velocity.x = player.velocity.x * (1 - velocityLerp) + targetVelocityX * velocityLerp;
            player.velocity.y = player.velocity.y * (1 - velocityLerp) + targetVelocityY * velocityLerp;
            
            // Apply movement
            let newX = player.x + moveX * player.speed;
            let newY = player.y + moveY * player.speed;

            // --- BEGIN OBSTACLE COLLISION CHECK --- 
            let collidedX = false;
            let collidedY = false;
            const playerSize = CONSTANTS.PLAYER.BASE_SIZE; // Use player base size for collision

            gameState.obstacles.forEach(obstacle => {
                if (!obstacle || !obstacle.type) return;
                
                // Correctly determine obstacle width and height based on orientation
                const obsWidth = obstacle.isHorizontal ? CONSTANTS.OBSTACLES.SIZE : CONSTANTS.OBSTACLES.THICKNESS;
                const obsHeight = obstacle.isHorizontal ? CONSTANTS.OBSTACLES.THICKNESS : CONSTANTS.OBSTACLES.SIZE;
                const obsX = obstacle.x;
                const obsY = obstacle.y;

                // Check collision with the *potential* new X position
                if (newX + playerSize/2 > obsX - obsWidth/2 && 
                    newX - playerSize/2 < obsX + obsWidth/2 && 
                    player.y + playerSize/2 > obsY - obsHeight/2 && 
                    player.y - playerSize/2 < obsY + obsHeight/2) {
                    collidedX = true;
                    // Push player back horizontally
                    if (moveX > 0) { // Moving right
                        newX = obsX - obsWidth/2 - playerSize/2 - 0.1; // Place just left of obstacle
                    } else if (moveX < 0) { // Moving left
                        newX = obsX + obsWidth/2 + playerSize/2 + 0.1; // Place just right of obstacle
                    }
                }

                // Check collision with the *potential* new Y position
                if (player.x + playerSize/2 > obsX - obsWidth/2 && 
                    player.x - playerSize/2 < obsX + obsWidth/2 && 
                    newY + playerSize/2 > obsY - obsHeight/2 && 
                    newY - playerSize/2 < obsY + obsHeight/2) {
                    collidedY = true;
                     // Push player back vertically
                    if (moveY > 0) { // Moving down
                        newY = obsY - obsHeight/2 - playerSize/2 - 0.1; // Place just above obstacle
                    } else if (moveY < 0) { // Moving up
                        newY = obsY + obsHeight/2 + playerSize/2 + 0.1; // Place just below obstacle
                    }
                }
            });
            // --- END OBSTACLE COLLISION CHECK ---

            // Update player position with collision checks applied
            player.x = newX;
            player.y = newY;

            // Keep in bounds (after collision check)
            player.x = Math.max(CONSTANTS.PLAYER.BASE_SIZE, Math.min(canvas.width - CONSTANTS.PLAYER.BASE_SIZE, player.x));
            player.y = Math.max(CONSTANTS.PLAYER.BASE_SIZE, Math.min(canvas.height - CONSTANTS.PLAYER.BASE_SIZE, player.y));

            // Rest of updatePlayer function...
            // ...

            // Update cooldowns - only decrement dashCooldown here
            if (player.dashCooldown > 0) player.dashCooldown--;
            // Note: shootCooldown is already handled above with rapid fire logic
            
            // Energy regeneration - boost by 200% when rapid fire is active
            let energyRegenRate = player.rapidFire ? CONSTANTS.PLAYER.ENERGY_REGEN * 3 : CONSTANTS.PLAYER.ENERGY_REGEN;
            if (player.radialBurstRegenPenalty > 0) {
                energyRegenRate *= 0.25; // 25% normal regen
                player.radialBurstRegenPenalty--;
            }
            player.energy = Math.min(player.maxEnergy, player.energy + energyRegenRate);
            
            // Decay shield
            if (player.shield > 0) {
                player.shield -= 0.1;
            }

            // Trail
                player.trail.push({x: player.x, y: player.y});
            if (player.trail.length > 10) player.trail.shift();

            // We've removed the trail checking here entirely - let checkForStuckKeys handle this
            // in a much less aggressive way

            // Shooting - bypass cooldown check when rapid fire is active
            if (gameState.mouseDown && player.energy >= CONSTANTS.PLAYER.SHOOT_COST && 
                (player.rapidFire || player.shootCooldown <= 0)) {
                shoot();
            }

            // In updatePlayer (or similar per-frame update for player):
            if (gameState.player.radialBurstCooldown > 0) gameState.player.radialBurstCooldown--;
        }

        function shoot() {
            const player = gameState.player;
            const angle = Math.atan2(
                gameState.mousePos.y - player.y,
                gameState.mousePos.x - player.x
            );

            if (player.multiShot) {
                // Create multiple bullets
                for (let i = -2; i <= 2; i++) {
                    const spreadAngle = angle + i * 0.1;
                    player.bullets.push({
                        x: player.x,
                        y: player.y,
                        dx: Math.cos(spreadAngle) * CONSTANTS.BULLET.SPEED,
                        dy: Math.sin(spreadAngle) * CONSTANTS.BULLET.SPEED,
                        lifetime: CONSTANTS.BULLET.LIFETIME
                    });
                }
            } else {
                // Create single bullet
                player.bullets.push({
                    x: player.x,
                    y: player.y,
                    dx: Math.cos(angle) * CONSTANTS.BULLET.SPEED,
                    dy: Math.sin(angle) * CONSTANTS.BULLET.SPEED,
                    lifetime: CONSTANTS.BULLET.LIFETIME
                });
            }

            // Only set cooldown if not using rapid fire
            // This way, rapid fire will be limited only by energy regeneration
            if (!player.rapidFire) {
                player.shootCooldown = CONSTANTS.PLAYER.SHOOT_COOLDOWN;
            }
            player.energy -= CONSTANTS.PLAYER.SHOOT_COST;

            // Play shoot sound
            SoundManager.playSound('SHOOT', 0.5); // Play SHOOT sound at 50% volume

            // Muzzle flash effect
            for (let i = 0; i < 5; i++) {
                gameState.particles.push(createParticle(
                    player.x, player.y,
                    COLORS.BULLET.CORE,
                    3, 4, 15,
                    true
                ));
            }
        }

        function updateBullets() {
            // Update player bullets
            gameState.player.bullets = gameState.player.bullets.filter(bullet => {
                // Move bullet
                bullet.x += bullet.dx;
                bullet.y += bullet.dy;
                
                // Check if bullet is off-screen
                if (bullet.x < 0 || bullet.x > canvas.width || 
                    bullet.y < 0 || bullet.y > canvas.height) {
                    return false;
                }
                
                // Check collision with walls/obstacles
                for (let obstacle of gameState.obstacles) {
                    const dx = bullet.x - obstacle.x;
                    const dy = bullet.y - obstacle.y;
                    
                    // Determine if collision occurred based on wall orientation
                    let collision = false;
                    
                    if (obstacle.isHorizontal) {
                        // Check horizontal wall collision with precise boundaries
                        if (Math.abs(dy) < CONSTANTS.BULLET.SIZE/2 + CONSTANTS.OBSTACLES.THICKNESS/2 &&
                            Math.abs(dx) < CONSTANTS.OBSTACLES.SIZE/2) {
                            collision = true;
                        }
                    } else {
                        // Check vertical wall collision with precise boundaries
                        if (Math.abs(dx) < CONSTANTS.BULLET.SIZE/2 + CONSTANTS.OBSTACLES.THICKNESS/2 &&
                            Math.abs(dy) < CONSTANTS.OBSTACLES.SIZE/2) {
                            collision = true;
                        }
                    }
                    
                    // If collision detected, create particles and remove bullet
                    if (collision) {
                        // Create particle effect when bullet hits wall
                        for (let i = 0; i < 5; i++) {
                            gameState.particles.push(createParticle(
                                bullet.x, bullet.y,
                                '#FFFFFF', // White spark
                                1, 2, 10,
                                true
                            ));
                        }
                        return false; // Remove bullet
                    }
                }
                
                // Check collision with enemies
                let hitEnemy = false;
                
                // Direct check for boss collision - FIXED COLLISION DETECTION
                gameState.enemies.forEach(enemy => {
                    if (enemy.type === 'BOSS') {
                        const dx = bullet.x - enemy.x;
                        const dy = bullet.y - enemy.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        // Make boss hitbox slightly larger for easier hits
                        if (dist < (CONSTANTS.BULLET.SIZE + enemy.size * 0.8)) {
                            hitEnemy = true;
                            
                            // Calculate damage
                            let damage = 40 * gameState.player.level.damage; // Higher base damage
                            
                            // Add visual hit flash effect
                            enemy.hitFlash = 10; // Flash for 10 frames
                            
                            // Add dramatic hit particles
                            for (let i = 0; i < 12; i++) {
                                gameState.particles.push(createParticle(
                                    bullet.x, bullet.y,
                                    '#FFFFFF', // White flash
                                    4, 5, 25,
                                    true
                                ));
                            }
                            
                            // If enemy has a shield, reduce that first
                            if (enemy.shield && enemy.shield > 0) {
                                enemy.shield -= damage;
                                if (enemy.shield < 0) {
                                    // Apply remaining damage to health
                                    enemy.health += enemy.shield;
                                    enemy.shield = 0;
                                }
                            } else {
                                // Apply damage directly to health
                                enemy.health -= damage;
                                // Log damage to console for debugging
                                console.log(`Boss hit! Damage: ${damage}, Health: ${enemy.health}`);
                            }
                            
                            // Check if boss is defeated
                            if (enemy.health <= 0) {
                                // Create explosion effect
                                for (let i = 0; i < 100; i++) {
                                    gameState.particles.push(createParticle(
                                        enemy.x, enemy.y,
                                        COLORS.ENEMY.BOSS.CORE,
                                        5, 8, 60,
                                        true
                                    ));
                                }
                                
                                // Give player extra score and health for defeating boss
                                gameState.player.score += 500;
                                gameState.player.health = Math.min(gameState.player.health + 50, gameState.player.maxHealth);
                                
                                // End boss fight
                                gameState.isBossFight = false;
                                gameState.bossDefeated = true;
                                
                                // Explicitly call checkWaveComplete to trigger wave transition
                                checkWaveComplete();
                                
                                // Remove the boss
                                gameState.enemies = gameState.enemies.filter(e => e !== enemy);
                                
                                return false;
                            }
                        }
                    }
                });
                 // Check collision with mines
        let hitMine = false;
        gameState.mines = gameState.mines.filter(mine => {
            // Check collision only if mine is armed
            if (mine.armTime <= 0) {
                const dx = bullet.x - mine.x;
                const dy = bullet.y - mine.y;
                const dist = Math.sqrt(dx*dx + dy*dy);

                // Use bullet size constant from CONSTANTS object if available, otherwise use a default
                const bulletRadius = (typeof CONSTANTS !== 'undefined' && CONSTANTS.BULLET && CONSTANTS.BULLET.SIZE) ? CONSTANTS.BULLET.SIZE / 2 : 3;
                if (dist < bulletRadius + mine.size) {
                    // Hit! Mark mine for removal and trigger effects
                    hitMine = true;

                    // Create explosion effect for mine destruction
                    for (let i = 0; i < 10; i++) { // Smaller explosion than player hitting mine
                        gameState.particles.push(createParticle(
                            mine.x, mine.y,
                            (typeof COLORS !== 'undefined' && COLORS.MINE) ? COLORS.MINE.ARMED : 'orange', // Use defined color or default
                            2, 4, 20, true
                        ));
                    }
                    // Add small score reward
                    gameState.player.score += 5;
                    // Ensure addFloatingText exists before calling
                    if (typeof addFloatingText === 'function') {
                         addFloatingText(mine.x, mine.y - mine.size, '+5', 'gold');
                    }

                    // Remove the mine
                    return false;
                }
            }
            return true; // Keep the mine if no collision or not armed
                });
                
                // Return false to remove the bullet if it hit an enemy
                return !(hitEnemy  || hitMine);
            });
            
            // Handle shooting - bypass cooldown check when rapid fire is active
            if (gameState.mouseDown && gameState.player.energy >= CONSTANTS.PLAYER.SHOOT_COST && 
                (gameState.player.rapidFire || gameState.player.shootCooldown <= 0)) {
                shootBullet();
            }
        }

        function shootBullet() {
            const player = gameState.player;
            const angle = Math.atan2(
                gameState.mousePos.y - player.y,
                gameState.mousePos.x - player.x
            );

            if (player.multiShot) {
                // Create multiple bullets
                for (let i = -2; i <= 2; i++) {
                    const spreadAngle = angle + i * 0.1;
                    player.bullets.push({
                        x: player.x,
                        y: player.y,
                        dx: Math.cos(spreadAngle) * CONSTANTS.BULLET.SPEED,
                        dy: Math.sin(spreadAngle) * CONSTANTS.BULLET.SPEED,
                        lifetime: CONSTANTS.BULLET.LIFETIME
                    });
                }
            } else {
                // Create single bullet
                player.bullets.push({
                    x: player.x,
                    y: player.y,
                    dx: Math.cos(angle) * CONSTANTS.BULLET.SPEED,
                    dy: Math.sin(angle) * CONSTANTS.BULLET.SPEED,
                    lifetime: CONSTANTS.BULLET.LIFETIME
                });
            }

            // Only set cooldown if not using rapid fire
            // This way, rapid fire will be limited only by energy regeneration
            if (!player.rapidFire) {
                player.shootCooldown = CONSTANTS.PLAYER.SHOOT_COOLDOWN;
            }
            player.energy -= CONSTANTS.PLAYER.SHOOT_COST;

            // Play shoot sound
            SoundManager.playSound('SHOOT', 0.5); // Play SHOOT sound at 50% volume

            // Muzzle flash effect
            for (let i = 0; i < 5; i++) {
                gameState.particles.push(createParticle(
                    player.x, player.y,
                    COLORS.BULLET.CORE,
                    3, 4, 15,
                    true
                ));
            }
        }

        function updateEnemyBullets() {
            // Update enemy bullets
            gameState.enemyBullets = gameState.enemyBullets.filter(bullet => {
                // Move bullet
                bullet.x += bullet.dx;
                bullet.y += bullet.dy;
                
                // Reduce lifetime
                bullet.lifetime--;
                
                // Remove if lifetime is over
                if (bullet.lifetime <= 0) {
                    return false;
                }
                
                // Check if bullet is off-screen
                if (bullet.x < 0 || bullet.x > canvas.width || 
                    bullet.y < 0 || bullet.y > canvas.height) {
                    return false;
                }
                
                // Check collision with walls/obstacles
                for (let obstacle of gameState.obstacles) {
                    const dx = bullet.x - obstacle.x;
                    const dy = bullet.y - obstacle.y;
                    
                    // Determine if collision occurred based on wall orientation
                    let collision = false;
                    
                    if (obstacle.isHorizontal) {
                        // Check horizontal wall collision with precise boundaries
                        if (Math.abs(dy) < (bullet.size || 8)/2 + CONSTANTS.OBSTACLES.THICKNESS/2 &&
                            Math.abs(dx) < CONSTANTS.OBSTACLES.SIZE/2) {
                            collision = true;
                        }
                    } else {
                        // Check vertical wall collision with precise boundaries
                        if (Math.abs(dx) < (bullet.size || 8)/2 + CONSTANTS.OBSTACLES.THICKNESS/2 &&
                            Math.abs(dy) < CONSTANTS.OBSTACLES.SIZE/2) {
                            collision = true;
                        }
                    }
                    
                    // If collision detected, create particles and remove bullet
                    if (collision) {
                        // Create particle effect when bullet hits wall
                        for (let i = 0; i < 5; i++) {
                            gameState.particles.push(createParticle(
                                bullet.x, bullet.y,
                                bullet.fromBoss ? COLORS.ENEMY.BOSS.CORE : '#FF4040',
                                1, 2, 10,
                                true
                            ));
                        }
                        return false; // Remove bullet
                    }
                }
                
                // Define bullet size based on source
                const bulletSize = bullet.fromBoss ? (bullet.size || 12) : 8;
                
                // Check collision with player
                const dx = gameState.player.x - bullet.x;
                const dy = gameState.player.y - bullet.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                // --- DEBUGGING COLLISION ---
                const collisionThreshold = CONSTANTS.PLAYER.BASE_SIZE + bulletSize * 0.5;
                const playerPos = gameState.player ? `(${gameState.player.x.toFixed(1)}, ${gameState.player.y.toFixed(1)})` : 'N/A';
                console.log(`Bullet Pos: (${bullet.x.toFixed(1)}, ${bullet.y.toFixed(1)}), Player Pos: ${playerPos}, Dist: ${dist.toFixed(1)}, Threshold: ${collisionThreshold.toFixed(1)} (PlayerSize: ${CONSTANTS.PLAYER.BASE_SIZE}, BulletSize: ${bulletSize})`);
                // --- END DEBUGGING ---
                
                if (dist < CONSTANTS.PLAYER.BASE_SIZE + bulletSize * 0.5) {
                    console.log("Enemy bullet hit player collision detected!"); // DEBUG
                    // If shield is active, reduce shield instead of health
                    if (gameState.player.shield > 0) {
                        console.log("Player shield is active."); // DEBUG
                        gameState.player.shield -= bullet.fromBoss ? 30 : 15;
                        if (gameState.player.shield < 0) gameState.player.shield = 0;
                        // Play shield hit sound
                        console.log("Attempting to play SHIELD_HIT sound."); // DEBUG
                        SoundManager.playSound('SHIELD_HIT', 0.7);
                    } else {
                        console.log("Player shield is NOT active."); // DEBUG
                        // Bullets from boss deal more damage
                        const damage = bullet.fromBoss ? 30 : 15; // Increased: boss bullets 30 (was 20), normal bullets 15 (was 10)
                        gameState.player.health -= damage;
                        // Play player hit sound
                        console.log("Attempting to play PLAYER_HIT sound."); // DEBUG
                        SoundManager.playSound('PLAYER_HIT', 0.8);
                        
                        // Check for game over
                        if (gameState.player.health <= 0) {
                            gameState.gameOver = true;
                        }
                    }
                    
                    // Create hit effect
                    for (let i = 0; i < 8; i++) {
                        gameState.particles.push(createParticle(
                            bullet.x, bullet.y,
                            bullet.fromBoss ? COLORS.ENEMY.BOSS.CORE : '#FF4040',
                            2, 3, 15,
                            true
                        ));
                    }
                    
                    return false;
                }
                
                // Keep bullet
                return true;
            });
        }

        // Helper function to check wall collision
        function checkWallCollision(entity, wall, entitySize) {
            const dx = entity.x - wall.x;
            const dy = entity.y - wall.y;
            
            const extraBuffer = 2; // Add extra buffer to collision detection to prevent phasing
            
            let collision = false;
            let pushX = 0;
            let pushY = 0;
            
            if (wall.isHorizontal) {
                const wallHalfLength = CONSTANTS.OBSTACLES.SIZE / 2;
                const wallHalfThickness = CONSTANTS.OBSTACLES.THICKNESS / 2;
                // Check horizontal wall collision with precise boundaries
                if (Math.abs(dy) < entitySize + wallHalfThickness + extraBuffer &&
                    Math.abs(dx) < wallHalfLength + extraBuffer) {
                    collision = true;
                    // Push vertically
                    const pushDir = dy > 0 ? 1 : -1;
                    pushY = pushDir * (entitySize + wallHalfThickness + extraBuffer - Math.abs(dy) + 1); // Stronger push out
                }
            } else if (!wall.isHorizontal) { // Vertical wall
                const wallHalfLength = CONSTANTS.OBSTACLES.SIZE / 2;
                const wallHalfThickness = CONSTANTS.OBSTACLES.THICKNESS / 2;
                // Check vertical wall collision with precise boundaries
                if (Math.abs(dx) < entitySize + wallHalfThickness + extraBuffer &&
                    Math.abs(dy) < wallHalfLength + extraBuffer) {
                     collision = true;
                    // Push horizontally
                    const pushDir = dx > 0 ? 1 : -1;
                    pushX = pushDir * (entitySize + wallHalfThickness + extraBuffer - Math.abs(dx) + 1); // Stronger push out
                }
            }
            
            if (collision) {
                // Apply the calculated push
                entity.x += pushX;
                entity.y += pushY;
                return true; // Collision occurred and push applied
            }
            
            return false; // No collision
        }

        // Helper function to check if a position is blocked by walls
        function isPositionBlocked(x, y, entitySize) {
            return gameState.obstacles.some(wall => {
                const dx = x - wall.x;
                const dy = y - wall.y;
                const buffer = 2; // Reduced buffer significantly from 8 to 2
                
                if (wall.isHorizontal) {
                    return Math.abs(dy) < entitySize + CONSTANTS.OBSTACLES.THICKNESS/2 + buffer &&
                           Math.abs(dx) < CONSTANTS.OBSTACLES.SIZE/2 + buffer;
                } else {
                    return Math.abs(dx) < entitySize + CONSTANTS.OBSTACLES.THICKNESS/2 + buffer &&
                           Math.abs(dy) < CONSTANTS.OBSTACLES.SIZE/2 + buffer;
                }
            });
        }

        // Helper function to check if there's a wall between two points
        function hasWallBetween(x1, y1, x2, y2, entitySize) {
            const steps = 30; // Increased steps for more precise path checking
            for (let i = 0; i <= steps; i++) {
                const x = x1 + (x2 - x1) * (i / steps);
                const y = y1 + (y2 - y1) * (i / steps);
                if (isPositionBlocked(x, y, entitySize)) {
                    return true;
                }
            }
            return false;
        }

        // Helper function to find a safe movement direction
        function findSafeDirection(enemy, targetX, targetY, speed) {
            const entitySize = enemy.size;
            const directions = [
                { dx: 1, dy: 0 },   // right
                { dx: -1, dy: 0 },  // left
                { dx: 0, dy: 1 },   // down
                { dx: 0, dy: -1 },  // up
                { dx: 1, dy: 1 },   // diagonal right-down
                { dx: -1, dy: 1 },  // diagonal left-down
                { dx: 1, dy: -1 },  // diagonal right-up
                { dx: -1, dy: -1 }  // diagonal left-up
            ];

            // Initialize properties if not present
            enemy.lastPosition = enemy.lastPosition || { x: enemy.x, y: enemy.y };
            enemy.stuckTime = enemy.stuckTime || 0;
            enemy.lastDirection = enemy.lastDirection || null;
            enemy.wallAvoidance = enemy.wallAvoidance || { x: 0, y: 0 };
            enemy.pathHistory = enemy.pathHistory || [];
            enemy.randomMoveTimer = enemy.randomMoveTimer || 0;
            enemy.randomDirection = enemy.randomDirection || null;
            
            // Add current position to path history
            enemy.pathHistory.push({ x: enemy.x, y: enemy.y });
            if (enemy.pathHistory.length > 10) enemy.pathHistory.shift();

            // Check if enemy is stuck (not moving much)
            const dx = enemy.x - enemy.lastPosition.x;
            const dy = enemy.y - enemy.lastPosition.y;
            const movement = Math.sqrt(dx * dx + dy * dy);
            
            if (movement < 0.2) { // Increased threshold from 0.05 to 0.2
                enemy.stuckTime++;
            } else {
                enemy.stuckTime = Math.max(0, enemy.stuckTime - 2); // Decrease faster
            }

            // Calculate angle to target
            const angleToTarget = Math.atan2(targetY - enemy.y, targetX - enemy.x);
            
            // Check for walls in the path
            const hasWall = hasWallBetween(enemy.x, enemy.y, targetX, targetY, entitySize);
            
            if (hasWall) {
                // Calculate perpendicular direction to wall
                const perpendicularAngle = angleToTarget + Math.PI/2;
                
                // Try multiple perpendicular directions
                const perpendicularDirs = [
                    { dx: Math.cos(perpendicularAngle), dy: Math.sin(perpendicularAngle) },
                    { dx: Math.cos(perpendicularAngle + Math.PI), dy: Math.sin(perpendicularAngle + Math.PI) }
                ];

                // Try moving perpendicular to the wall
                for (let dir of perpendicularDirs) {
                    const newX = enemy.x + dir.dx * speed;
                    const newY = enemy.y + dir.dy * speed;
                    
                    if (!isPositionBlocked(newX, newY, entitySize)) {
                        // Check if this direction gets us closer to target
                        const currentDist = Math.sqrt(
                            Math.pow(targetX - enemy.x, 2) + 
                            Math.pow(targetY - enemy.y, 2)
                        );
                        const newDist = Math.sqrt(
                            Math.pow(targetX - newX, 2) + 
                            Math.pow(targetY - newY, 2)
                        );
                        
                        if (newDist < currentDist) {
                            enemy.wallAvoidance = dir;
                            return dir;
                        }
                    }
                }
            }

            // If stuck, try to find any safe direction
            if (enemy.stuckTime > 5) {
                // Pick a completely random direction to escape
                const randomAngle = Math.random() * Math.PI * 2;
                const randomDir = {
                    dx: Math.cos(randomAngle),
                    dy: Math.sin(randomAngle)
                };
                
                // Set a timer to follow this random direction for a bit
                enemy.randomDirection = randomDir;
                enemy.randomMoveTimer = 15;
                enemy.stuckTime = 0;
                
                return randomDir;
            }

            // Try to move towards target while avoiding walls
            let bestDirection = null;
            let bestDistance = Infinity;

            for (let dir of directions) {
                const newX = enemy.x + dir.dx * speed;
                const newY = enemy.y + dir.dy * speed;
                
                if (!isPositionBlocked(newX, newY, entitySize)) {
                    const dx = targetX - newX;
                    const dy = targetY - newY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < bestDistance) {
                        bestDistance = dist;
                        bestDirection = dir;
                    }
                }
            }

            // Update last position and direction
            enemy.lastPosition = { x: enemy.x, y: enemy.y };
            if (bestDirection) {
                enemy.lastDirection = bestDirection;
            }

            return bestDirection;
        }

        function updateEnemies() {
            // Spawn enemies
            if (!gameState.waveComplete && !gameState.isBossFight && gameState.enemies.length < (gameState.currentWave <= 5 ? 5 : 8) && // Wave-based enemy cap (5 for 1-5, 8 for 6+)
                gameState.enemiesDefeated < gameState.enemiesPerWave) { 
                if (Math.random() < 0.08) { // Increased spawn chance from 0.02 to 0.08 (8%)
                    spawnEnemy();
                }
            }

            // Apply time warp speed reduction if active
            const speedMultiplier = gameState.timeWarpActive ? 0.4 : 1.0;
            
            // Update existing enemies
            gameState.enemies = gameState.enemies.filter(enemy => {
                // Skip updates for enemies that are off-screen by a large margin
                if (enemy.x < -100 || enemy.x > canvas.width + 100 || 
                    enemy.y < -100 || enemy.y > canvas.height + 100) {
                    return true; // Keep enemy in array but skip updates
                }
                
                // Calculate distance to player
                const dx = gameState.player.x - enemy.x;
                const dy = gameState.player.y - enemy.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                // Handle boss behavior
                if (enemy.type === 'BOSS') {
                    // Update hit flash effect if active
                    if (enemy.hitFlash > 0) {
                        enemy.hitFlash--;
                    }
                    
                    // Boss behavior
                    enemy.attackTimer--;
                    
                    if (enemy.attackTimer <= 0) {
                        // Change attack pattern periodically
                        enemy.attackPattern = (enemy.attackPattern + 1) % 3;
                        enemy.attackTimer = 300;  // 5 seconds at 60fps
                        
                        // Create visual effect for pattern change
                        for (let i = 0; i < 30; i++) {
                            gameState.particles.push(createParticle(
                                enemy.x, enemy.y,
                                COLORS.ENEMY.BOSS.CORE,
                                3, 5, 40,
                                true
                            ));
                        }
                    }
                    
                    // Phase transition at 50% health
                    if (enemy.health <= enemy.maxHealth * 0.5 && enemy.phase === 1) {
                        enemy.phase = 2;
                        enemy.shield = 75;  // Reduced from 150 to 75
                        
                        // Visual effect for phase change
                        for (let i = 0; i < 50; i++) {
                            gameState.particles.push(createParticle(
                                enemy.x, enemy.y,
                                '#FFFFFF',
                                5, 8, 60,
                                true
                            ));
                        }
                    }
                    
                    // Different movement patterns
                    if (enemy.attackPattern === 0) {
                        // Pattern 0: Side to side movement
                        enemy.moveDirection = enemy.moveDirection || 1;
                        enemy.x += enemy.moveDirection * enemy.speed;
                        
                        // Reverse direction at screen edges
                        if (enemy.x < enemy.size || enemy.x > canvas.width - enemy.size) {
                            enemy.moveDirection *= -1;
                        }
                    } else if (enemy.attackPattern === 1) {
                        // Pattern 1: Circle around the player
                        const circleRadius = 300;
                        const circleSpeed = 0.01;
                        
                        // Initialize or update circle position
                        enemy.circleAngle = (enemy.circleAngle || 0) + circleSpeed;
                        
                        // Calculate new position
                        enemy.x = gameState.player.x + Math.cos(enemy.circleAngle) * circleRadius;
                        enemy.y = gameState.player.y + Math.sin(enemy.circleAngle) * circleRadius;
                        
                        // Keep in bounds
                        enemy.x = Math.max(enemy.size, Math.min(canvas.width - enemy.size, enemy.x));
                        enemy.y = Math.max(enemy.size, Math.min(canvas.height - enemy.size, enemy.y));
                    } else {
                        // Pattern 2: Direct approach then retreat
                        if (dist > 250) {
                            // Approach player
                            enemy.x += dx / dist * enemy.speed;
                            enemy.y += dy / dist * enemy.speed;
                        } else {
                            // Retreat from player
                            enemy.x -= dx / dist * enemy.speed;
                            enemy.y -= dy / dist * enemy.speed;
                        }
                    }
                    
                    // Boss attacks
                    enemy.bulletCooldown--;
                    
                    if (enemy.bulletCooldown <= 0) {
                        // Different attacks based on phase
                        if (enemy.phase === 1) {
                            // Phase 1 attack: Spiral bullets
                            const bulletCount = 8;
                            for (let i = 0; i < bulletCount; i++) {
                                const angle = (enemy.circleAngle || 0) + (Math.PI * 2 * i / bulletCount);
                                
                                gameState.enemyBullets.push({
                                    x: enemy.x,
                                    y: enemy.y,
                                    dx: Math.cos(angle) * 3,
                                    dy: Math.sin(angle) * 3,
                                    lifetime: 120,
                                    fromBoss: true
                                });
                            }
                        } else {
                            // Phase 2 attack: Targeted shots + random bullets
                            
                            // Targeted shot at player
                            const angle = Math.atan2(dy, dx);
                            gameState.enemyBullets.push({
                                x: enemy.x,
                                y: enemy.y,
                                dx: Math.cos(angle) * 5,
                                dy: Math.sin(angle) * 5,
                                lifetime: 120,
                                fromBoss: true,
                                size: 15
                            });
                            
                            // Random spread shots
                            for (let i = 0; i < 5; i++) {
                                const randomAngle = Math.random() * Math.PI * 2;
                                gameState.enemyBullets.push({
                                    x: enemy.x,
                                    y: enemy.y,
                                    dx: Math.cos(randomAngle) * 4,
                                    dy: Math.sin(randomAngle) * 4,
                                    lifetime: 90,
                                    fromBoss: true
                                });
                            }
                        }
                        
                        // Visual effect
                        for (let i = 0; i < 15; i++) {
                            gameState.particles.push(createParticle(
                                enemy.x, enemy.y,
                                COLORS.ENEMY.BOSS.CORE,
                                3, 5, 30,
                                true
                            ));
                        }
                        
                        // Reset cooldown (faster in phase 2)
                        enemy.bulletCooldown = enemy.phase === 1 ? 60 : 45;
                    }
                    
                    // Continuous particle effect for boss
                    if (Math.random() < 0.2) {
                        gameState.particles.push(createParticle(
                            enemy.x + (Math.random() - 0.5) * enemy.size,
                            enemy.y + (Math.random() - 0.5) * enemy.size,
                            COLORS.ENEMY.BOSS.CORE,
                            1, 
                            enemy.size * 0.2,
                            30,
                            true
                        ));
                    }
                    
                    // Check if boss is defeated
                    if (enemy.health <= 0) {
                        // Boss defeated effects
                        for (let i = 0; i < 100; i++) {
                            gameState.particles.push(createParticle(
                                enemy.x, enemy.y,
                                COLORS.ENEMY.BOSS.CORE,
                                8, 10, 120,
                                true
                            ));
                        }
                        
                        // Give player extra score and health for defeating boss
                        gameState.player.score += 500;
                        gameState.player.health = Math.min(gameState.player.health + 50, gameState.player.maxHealth);
                        
                        // End boss fight
                        gameState.isBossFight = false;
                        gameState.bossDefeated = true;
                        
                        // Explicitly call checkWaveComplete to trigger wave transition
                        checkWaveComplete();
                        
                        // Remove the boss
                        gameState.enemies = gameState.enemies.filter(e => e !== enemy);
                        
                        return false;
                    }
                    
                    return true;
                } else if (enemy.type === 'SHOOTER') {
                    // Shooter specific behavior - keep at a distance and fire
                    const targetDist = 300;
                    
                    if (dist < targetDist - 50) {
                        // Too close, move away
                        enemy.x -= dx / dist * enemy.speed * speedMultiplier;
                        enemy.y -= dy / dist * enemy.speed * speedMultiplier;
                    } else if (dist > targetDist + 50) {
                        // Too far, move closer
                        enemy.x += dx / dist * enemy.speed * speedMultiplier;
                        enemy.y += dy / dist * enemy.speed * speedMultiplier;
                    }
                    
                    // Shooting logic
                    enemy.bulletCooldown--;
                    
                    if (enemy.bulletCooldown <= 0 && dist < 500) {
                        // Fire a bullet at the player
                        gameState.enemyBullets.push({
                            x: enemy.x,
                            y: enemy.y,
                            dx: dx / dist * 5,
                            dy: dy / dist * 5,
                            lifetime: 60
                        });
                        
                        // Create particle effect
                        for (let i = 0; i < 5; i++) {
                            gameState.particles.push(createParticle(
                                enemy.x, enemy.y,
                                COLORS.ENEMY.SHOOTER.CORE,
                                2, 3, 15,
                                true
                            ));
                        }
                        
                        // Reset cooldown
                        enemy.bulletCooldown = 45;
                    }
                } else if (enemy.type === 'BOMBER') {
                    // Bomber approaches and explodes
                    enemy.chargeTimer = enemy.chargeTimer || 60;
                    enemy.chargeTimer--;
                    enemy.isCharging = enemy.isCharging || false;

                    if (enemy.chargeTimer <= 0 && !enemy.isCharging) {
                        // Begin charge - now directly targets the player
                        enemy.isCharging = true;
                        enemy.chargeTime = 60; // Increased from 45 to 60 for longer dash
                        enemy.chargeSpeed = enemy.speed * 3.5; // Increased from 2.5 to 3.5 for faster dash
                    }

                    if (enemy.isCharging) {
                        // During charge, track player with mid-air direction changes
                        enemy.chargeTime--;

                        // Update target to player's current position (tracking)
                        // Every 5 frames (reduced from 10), recalculate trajectory to home in on player
                        if (enemy.chargeTime % 5 === 0) {
                            enemy.chargeTarget = {
                                x: gameState.player.x,
                                y: gameState.player.y
                            };
                        }

                        // Calculate direction to updated target
                        const targetX = enemy.chargeTarget ? enemy.chargeTarget.x : gameState.player.x;
                        const targetY = enemy.chargeTarget ? enemy.chargeTarget.y : gameState.player.y;
                        const targetDx = targetX - enemy.x;
                        const targetDy = targetY - enemy.y;
                        const targetDist = Math.sqrt(targetDx * targetDx + targetDy * targetDy);

                        // Move faster during charge with tracking
                        if (targetDist > 0) {
                            enemy.x += targetDx / targetDist * enemy.chargeSpeed * speedMultiplier;
                            enemy.y += targetDy / targetDist * enemy.chargeSpeed * speedMultiplier;

                            // Add trailing particles for visual effect
                            if (Math.random() < 0.6) { // Increased from 0.4 to 0.6 for more particles
                                gameState.particles.push(createParticle(
                                    enemy.x, enemy.y,
                                    COLORS.ENEMY.BOMBER.CORE,
                                    3, 4, 25, // Increased size and lifetime
                                    true
                                ));
                            }
                        }

                        if (enemy.chargeTime <= 0) {
                            enemy.isCharging = false;
                            enemy.chargeTimer = 75; // Reduced from 90 to 75 for more frequent charges
                        }
                    } else {
                        // Normal movement when not charging
                        const dx = gameState.player.x - enemy.x;
                        const dy = gameState.player.y - enemy.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        // Move towards player at normal speed when not charging
                        if (dist > 0) {
                            enemy.x += dx / dist * enemy.speed * speedMultiplier * 0.9; // Increased from 0.7 to 0.9 for faster approach
                            enemy.y += dy / dist * enemy.speed * speedMultiplier * 0.9; // Increased from 0.7 to 0.9
                        }
                    }
                } else if (enemy.type === 'ELITE') {
                    // Elite enemy behavior
                    enemy.shield = enemy.shield || 50;
                    enemy.teleportCooldown = enemy.teleportCooldown || 180;
                    enemy.attackCooldown = enemy.attackCooldown || 120;
                    enemy.justTeleported = enemy.justTeleported || false;
                    
                    enemy.teleportCooldown--;
                    if (!enemy.justTeleported) {
                        enemy.attackCooldown--;
                    }
                    
                    if (enemy.teleportCooldown <= 0 || (enemy.health < enemy.maxHealth * 0.3 && enemy.teleportCooldown <= 60)) {
                        // Teleport effect for departure
                        createTeleportEffect(enemy.x, enemy.y);
                        
                        // Find a safe position to teleport to
                        const angle = Math.random() * Math.PI * 2;
                        const distance = 200 + Math.random() * 200;
                        enemy.x = gameState.player.x + Math.cos(angle) * distance;
                        enemy.y = gameState.player.y + Math.sin(angle) * distance;
                        
                        // Teleport effect for arrival
                        createTeleportEffect(enemy.x, enemy.y);
                        
                        // Flag to trigger immediate attack after teleport
                        enemy.justTeleported = true;
                        
                        // Reset teleport cooldown (reduced from 180 to make them teleport more frequently)
                        enemy.teleportCooldown = 150;
                    }
                    
                    // Move towards player
                    enemy.x += dx / dist * enemy.speed * speedMultiplier * 0.5;
                    enemy.y += dy / dist * enemy.speed * speedMultiplier * 0.5;
                    
                    // Attack logic - now shoots immediately after teleporting and shoots more frequently
                    if ((enemy.attackCooldown <= 0 || enemy.justTeleported) && dist < 600) {
                        // Immediate attack after teleport or regular attack cooldown
                        const bulletCount = 8;
                        for (let i = 0; i < bulletCount; i++) {
                            const spreadAngle = Math.atan2(dy, dx) + (Math.PI * 2 * i / bulletCount);
                            
                            gameState.enemyBullets.push({
                                x: enemy.x,
                                y: enemy.y,
                                dx: Math.cos(spreadAngle) * 4.5, // Slightly faster bullets
                                dy: Math.sin(spreadAngle) * 4.5,
                                lifetime: 60,
                                fromElite: true
                            });
                        }
                        
                        // Visual effect for the attack
                        for (let i = 0; i < 12; i++) {
                            gameState.particles.push(createParticle(
                                enemy.x, enemy.y,
                                COLORS.ENEMY.ELITE.CORE,
                                3, 4, 20,
                                true
                            ));
                        }
                        
                        // Reset the teleport attack flag
                        enemy.justTeleported = false;
                        
                        // Faster attack cooldown (reduced from 120)
                        enemy.attackCooldown = 90;
                    }
                } else if (enemy.type === 'HEALER') {
                    // Healer specific behavior
                    if (enemy.healCooldown > 0) {
                        enemy.healCooldown--;
                    } else {
                        // Healer will always try to heal if cooldown is ready, regardless of player distance
                        let targetHealed = false;
                        let closestDamagedEnemy = null;
                        // Find closest damaged ally (not self, not other healers) - REMOVED healRange constraint
                        let minDamagedDist = Infinity; // Start with infinity to find any damaged ally

                        gameState.enemies.forEach(otherEnemy => {
                            if (otherEnemy !== enemy && otherEnemy.type !== 'HEALER' && otherEnemy.health < otherEnemy.maxHealth) {
                                const d = Math.hypot(enemy.x - otherEnemy.x, enemy.y - otherEnemy.y);
                                if (d < minDamagedDist) { // Find the closest one to prioritize
                                    minDamagedDist = d;
                                    closestDamagedEnemy = otherEnemy;
                                }
                            }
                        });

                        if (closestDamagedEnemy) {
                            // Heal the target
                            closestDamagedEnemy.health = Math.min(closestDamagedEnemy.maxHealth, closestDamagedEnemy.health + enemy.healAmount);
                            enemy.healCooldown = 120; // Reset cooldown
                            targetHealed = true;

                            // Add healing particle effect
                            for (let i = 0; i < 3; i++) { // Fewer particles for heal
                                gameState.particles.push(createParticle(
                                    enemy.x, enemy.y,
                                    COLORS.ENEMY.HEALER.GLOW, // Use glow color
                                    1, 3, 30,
                                    true,
                                    closestDamagedEnemy // Target particle destination
                                ));
                            }
                             // Add floating text on healed enemy
                            addFloatingText(closestDamagedEnemy.x, closestDamagedEnemy.y - closestDamagedEnemy.size, `+${enemy.healAmount}`, 'lime');
                        }
                    }
                    // Healer movement: Move AWAY from the player
                     enemy.x -= dx / dist * enemy.speed * 0.7; // Slower move speed, and reversed direction
                     enemy.y -= dy / dist * enemy.speed * 0.7; // Slower move speed, and reversed direction

                     // Keep healer in bounds after moving away
                    enemy.x = Math.max(enemy.size, Math.min(canvas.width - enemy.size, enemy.x));
                    enemy.y = Math.max(enemy.size, Math.min(canvas.height - enemy.size, enemy.y));

                } else if (enemy.type === 'MINELAYER') {
                    // --- MINELAYER LOGIC --- 
                    if (enemy.mineCooldown > 0) {
                        enemy.mineCooldown--;
                    } else {
                        // Lay a mine
                        gameState.mines.push({
                            x: enemy.x,
                            y: enemy.y,
                            size: 10,
                            armTime: 90, // Frames until armed (1.5 seconds)
                            lifetime: 600, // Frames until disappears (10 seconds)
                            damage: 50, // Damage if player hits it
                            radius: 75 // Explosion radius
                        });
                        enemy.mineCooldown = 120 + Math.random() * 60; // Reset cooldown (2-3 seconds)
                    }
                    
                    // Minelayer movement: Try to stay at a distance from the player
                    const idealDistance = 300;
                    if (dist < idealDistance - 50) { // Too close, move away
                        enemy.x -= dx / dist * enemy.speed * speedMultiplier * 1.2; // Move away faster
                        enemy.y -= dy / dist * enemy.speed * speedMultiplier * 1.2;
                    } else if (dist > idealDistance + 50) { // Too far, move closer
                         enemy.x += dx / dist * enemy.speed * speedMultiplier * 0.7; // Move closer slower
                         enemy.y += dy / dist * enemy.speed * speedMultiplier * 0.7;
                    } else { // Maintain distance - strafe slowly?
                        // Optional: add slight sideways movement here later
                    }
                    // --- END MINELAYER LOGIC ---
                
                } else if (enemy.type === 'TURRET') {
                     // --- TURRET LOGIC (State Machine) ---
                    const playerDist = dist; // Use pre-calculated distance

                    // State: IDLE (Waiting for cooldown)
                    if (enemy.turretState === 'IDLE') {
                        if (enemy.fireCooldown > 0) {
                            enemy.fireCooldown--;
                        } else {
                            // Cooldown finished, start charging
                            enemy.turretState = 'CHARGING';
                            enemy.chargeTimer = 0;
                        }
                        // Very slow movement in IDLE state
                        enemy.x += dx / dist * enemy.speed * speedMultiplier * 0.5;
                        enemy.y += dy / dist * enemy.speed * speedMultiplier * 0.5;
                    }
                    // State: CHARGING
                    else if (enemy.turretState === 'CHARGING') {
                        enemy.chargeTimer++;
                        // Keep aiming at the player during charge
                        enemy.targetAngle = Math.atan2(dy, dx);
                        
                        // Stop moving while charging
                        // Add charging visual effect here later

                        if (enemy.chargeTimer >= enemy.chargeDuration) {
                            // Charge complete, start firing
                            enemy.turretState = 'FIRING';
                            enemy.shotsFired = 0;
                        }
                    }
                    // State: FIRING (Burst)
                    else if (enemy.turretState === 'FIRING') {
                        // Decrement cooldown between shots in burst
                        if (enemy.fireCooldown > 0) {
                             enemy.fireCooldown--;
                        } else if (enemy.shotsFired < enemy.shotsPerBurst) {
                            // Fire one shot of the burst
                             gameState.enemyBullets.push({
                                x: enemy.x,
                                y: enemy.y,
                                dx: Math.cos(enemy.targetAngle) * 6, // Faster bullets
                                dy: Math.sin(enemy.targetAngle) * 6,
                                lifetime: 75 // Longer lifetime
                            });
                            enemy.shotsFired++;
                            enemy.fireCooldown = enemy.burstDelay; // Set delay for next shot
                             // Add firing visual effect here later
                        }
                         else {
                            // Burst finished, go to COOLDOWN (This code should remain)
                            enemy.turretState = 'IDLE';
                            enemy.fireCooldown = enemy.fireCooldownDuration; // Start main cooldown
                            enemy.chargeTimer = 0; // Reset charge timer
                        }
                        // Stop moving while firing
                    }
                     // --- END TURRET LOGIC ---

                } else {
                    // Default enemy behavior (NORMAL, FAST, TANK)
                    // Apply slowdown if enemy has recently collided with a wall
                    const slowdownFactor = enemy.tempSlowdown > 0 ? 0.3 : 1.0;
                    
                    // Check for walls and use pathfinding to avoid them
                    const safeDirection = findSafeDirection(enemy, gameState.player.x, gameState.player.y, enemy.speed * speedMultiplier * slowdownFactor);
                    
                    if (safeDirection) {
                        // Use smaller movement steps to prevent phasing through walls
                        // Move in multiple smaller steps instead of one big step
                        const totalDx = safeDirection.dx * enemy.speed * speedMultiplier * slowdownFactor;
                        const totalDy = safeDirection.dy * enemy.speed * speedMultiplier * slowdownFactor;
                        const steps = 5; // Increased from 3 to 5 steps for more careful movement
                        
                        // Move in smaller steps, checking for collisions at each step
                        for (let i = 1; i <= steps; i++) {
                            const nextX = enemy.x + (totalDx / steps);
                            const nextY = enemy.y + (totalDy / steps);
                            
                            // Check if this smaller step would cause a collision using isPositionBlocked first
                            if (!isPositionBlocked(nextX, nextY, enemy.size / 2)) { // Use radius for check
                                enemy.x = nextX;
                                enemy.y = nextY;
                            } else {
                                // If potential collision, try a final check/push using checkWallCollision
                                // Find the specific wall causing the block (optional, but potentially more accurate)
                                let blockingWall = gameState.obstacles.find(wall => {
                                    const checkDx = nextX - wall.x;
                                    const checkDy = nextY - wall.y;
                                    const buffer = 2; 
                                    const wallHalfThick = CONSTANTS.OBSTACLES.THICKNESS/2;
                                    const wallHalfSize = CONSTANTS.OBSTACLES.SIZE/2;
                                    if (wall.isHorizontal) {
                                        return Math.abs(checkDy) < enemy.size/2 + wallHalfThick + buffer && Math.abs(checkDx) < wallHalfSize + buffer;
                                    } else {
                                        return Math.abs(checkDx) < enemy.size/2 + wallHalfThick + buffer && Math.abs(checkDy) < wallHalfSize + buffer;
                                    }
                                });
                                
                                // If a specific wall is found, attempt pushback
                                if (blockingWall) {
                                    checkWallCollision(enemy, blockingWall, enemy.size / 2); // Use radius
                                }
                                // Stop further steps after collision/pushback
                                break; 
                            }
                        }
                    } else {
                        // Fallback if no safe direction (should rarely happen)
                        // Use the old direct movement but with position check
                        const newX = enemy.x + dx / dist * enemy.speed * speedMultiplier * slowdownFactor;
                        const newY = enemy.y + dy / dist * enemy.speed * speedMultiplier * slowdownFactor;
                        
                        if (!isPositionBlocked(newX, newY, enemy.size)) {
                            enemy.x = newX;
                            enemy.y = newY;
                        }
                    }
                }
                
                // Reduce particle generation for better performance
                if (Math.random() < 0.05) {
                    gameState.particles.push(createParticle(
                        enemy.x, enemy.y,
                        COLORS.ENEMY[enemy.type] ? COLORS.ENEMY[enemy.type].CORE : 'red',
                        1, 
                        enemy.size * 0.3,
                        20
                    ));
                }
                
                // Check collisions and bullet hits
                // Return true to keep the enemy, false to remove it
                return !checkEnemyCollisions(enemy, dist);
            });
        }
        // --- Add updateMines and drawMines functions ---
function updateMines() {
    gameState.mines = gameState.mines.filter(mine => {
        // Countdown lifetime and arming time
        mine.lifetime--;
        if (mine.armTime > 0) {
            mine.armTime--;
        }

        // Remove if lifetime expires
        if (mine.lifetime <= 0) {
            return false;
        }

        // Check collision with player only if armed
        if (mine.armTime <= 0) {
            const dx = gameState.player.x - mine.x;
            const dy = gameState.player.y - mine.y;
            const dist = Math.sqrt(dx*dx + dy*dy);

            if (dist < CONSTANTS.PLAYER.BASE_SIZE + mine.size) {
                // Collision! Damage player
                 if (gameState.player.shield > 0) {
                    gameState.player.shield -= mine.damage * 0.8; // Mines do slightly less damage to shields
                    if (gameState.player.shield < 0) gameState.player.shield = 0;
                    SoundManager.playSound('SHIELD_HIT', 0.6); // Use shield hit sound
                } else {
                    gameState.player.health -= mine.damage;
                    SoundManager.playSound('PLAYER_HIT', 0.9); // Use player hit sound
                    if (gameState.player.health <= 0) {
                        gameState.gameOver = true;
                    }
                }

// Create explosion effect
for (let i = 0; i < 20; i++) { // Big explosion
     gameState.particles.push(createParticle(
        mine.x, mine.y,
        COLORS.MINE.ARMED,
        3, 6, 40, true
    ));
}
addFloatingText(gameState.player.x, gameState.player.y - 20, `-${mine.damage}`, 'red');

return false; // Remove mine after collision
}
}

return true; // Keep the mine
});
}

function drawMines() {
gameState.mines.forEach(mine => {
ctx.save();
const isArmed = mine.armTime <= 0;
const color = isArmed ? COLORS.MINE.ARMED : COLORS.MINE.ARMING;

// Pulsing effect for armed mines
let size = mine.size;
let alpha = 1.0;
if (isArmed) {
const pulse = Math.sin(Date.now() / 150); // Faster pulse
size = mine.size * (1 + pulse * 0.2);
alpha = 0.7 + pulse * 0.3;
if (!reducedEffects) {
 drawGlow(mine.x, mine.y, size * 2.5, COLORS.MINE.GLOW);
}
}

// Draw mine body
ctx.globalAlpha = alpha;
ctx.fillStyle = color;
ctx.beginPath();
ctx.arc(mine.x, mine.y, size, 0, Math.PI * 2);
ctx.fill();

// Draw arming timer or armed indicator (optional)
 if (!isArmed) {
    // Draw shrinking arc for arm timer
    ctx.strokeStyle = 'white';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(mine.x, mine.y, size + 2, -Math.PI/2, -Math.PI/2 + (Math.PI * 2 * (1 - mine.armTime / 90)));
    ctx.stroke();
}

ctx.restore();
});
}
// --- End add updateMines and drawMines ---

        function spawnEnemy() {
            const side = Math.floor(Math.random() * 4);
            let x, y;

            switch(side) {
                case 0: x = Math.random() * canvas.width; y = -20; break;
                case 1: x = canvas.width + 20; y = Math.random() * canvas.height; break;
                case 2: x = Math.random() * canvas.width; y = canvas.height + 20; break;
                case 3: x = -20; y = Math.random() * canvas.height; break;
            }

            // Randomly select enemy type based on current wave
            const enemyTypes = ['NORMAL', 'FAST', 'TANK', 'SHOOTER', 'BOMBER', 'ELITE', 'HEALER', 'MINELAYER', 'TURRET', 'SPLITTER']; // Added new types
            let availableTypes = ['NORMAL'];
            
            // Add more enemy types as waves progress - made easier for early waves
            if (gameState.currentWave >= 3) availableTypes.push('HEALER'); // HEALER starts Wave 3
            if (gameState.currentWave >= 3) availableTypes.push('FAST'); // Was 2
            if (gameState.currentWave >= 4) availableTypes.push('TANK'); // Was 3
            if (gameState.currentWave >= 5) availableTypes.push('SHOOTER'); // Was 4
            if (gameState.currentWave >= 6) availableTypes.push('MINELAYER'); // MINELAYER starts Wave 6
            if (gameState.currentWave >= 6) availableTypes.push('BOMBER'); // Was 5
            if (gameState.currentWave >= 7) availableTypes.push('TURRET'); // TURRET starts Wave 7
            if (gameState.currentWave >= 7) availableTypes.push('ELITE'); // Was 6
            if (gameState.currentWave >= 8) availableTypes.push('SPLITTER'); // SPLITTER starts Wave 8
            
            // Don't spawn normal enemies during boss fight
            if (gameState.isBossFight) {
                return;
            }
            
            const enemyType = availableTypes[Math.floor(Math.random() * availableTypes.length)];
            
            let enemyConfig = {
                x,
                y,
                type: enemyType,
                bulletCooldown: 0,
                tempSlowdown: 0, // Initialize tempSlowdown to prevent wall phasing
                stuckTime: 0,    // Initialize stuckTime for wall avoidance
                lastPosition: { x, y } // Track last position for stuck detection
            };
            
            // Set enemy-specific properties - weakened for early waves
            switch(enemyType) {
                case 'NORMAL':
                    // Reduced health and speed for early waves
                    if (gameState.currentWave <= 3) {
                        enemyConfig.speed = 1.5 + Math.random() * 0.5;
                        enemyConfig.health = 80;
                        enemyConfig.maxHealth = 80;
                    } else {
                        enemyConfig.speed = 2 + Math.random();
                        enemyConfig.health = 100;
                        enemyConfig.maxHealth = 100;
                    }
                    enemyConfig.size = 20;
                    break;
                case 'FAST':
                    if (gameState.currentWave <= 3) {
                        enemyConfig.speed = 2.5 + Math.random() * 1;
                        enemyConfig.health = 40;
                        enemyConfig.maxHealth = 40;
                    } else {
                        enemyConfig.speed = 3.5 + Math.random() * 1.5;
                        enemyConfig.health = 60;
                        enemyConfig.maxHealth = 60;
                    }
                    enemyConfig.size = 15;
                    break;
                case 'TANK':
                    enemyConfig.speed = 1 + Math.random() * 0.5;
                    enemyConfig.health = 200;
                    enemyConfig.maxHealth = 200;
                    enemyConfig.size = 30;
                    break;
                case 'SHOOTER':
                    enemyConfig.speed = 1.5 + Math.random();
                    enemyConfig.health = 80;
                    enemyConfig.maxHealth = 80;
                    enemyConfig.size = 22;
                    enemyConfig.bulletCooldown = 0;
                    break;
                case 'BOMBER':
                    enemyConfig.speed = 1.5 + Math.random(); // Increased from 1 to 1.5 for faster base speed
                    enemyConfig.health = 100;
                    enemyConfig.maxHealth = 100;
                    enemyConfig.size = 20;
                    break;
                case 'ELITE':
                    enemyConfig.speed = 1.5 + Math.random();
                    enemyConfig.health = 120;
                    enemyConfig.maxHealth = 120;
                    enemyConfig.size = 25;
                    break;
                case 'HEALER':
                    enemyConfig.speed = 1.8 + Math.random() * 0.4; // Moderate speed
                    enemyConfig.health = 70; // Lower health
                    enemyConfig.maxHealth = 70;
                    enemyConfig.size = 18;
                    enemyConfig.healCooldown = 120; // Frames between heals (2 seconds)
                    enemyConfig.healRange = 250; // How close it needs to be to heal
                    enemyConfig.healAmount = 15; // How much it heals per tick
                    break;
                case 'MINELAYER':
                    enemyConfig.speed = 1.5 + Math.random(); // Moves slowly to position
                    enemyConfig.health = 100;
                    enemyConfig.maxHealth = 100;
                    enemyConfig.size = 20;
                    enemyConfig.mineCooldown = 120; // Frames between mines (2 seconds)
                    // Removed mineRange, not needed here
                    break;
                case 'TURRET':
                    enemyConfig.speed = 0.3 + Math.random() * 0.2; // Very slow speed, mostly stationary
                    enemyConfig.health = 200; // Tanky health
                    enemyConfig.maxHealth = 200;
                    enemyConfig.size = 28; // Slightly larger
                    enemyConfig.turretState = 'IDLE'; // Initial state
                    enemyConfig.chargeTimer = 0;
                    enemyConfig.chargeDuration = 180; // Frames to charge (3 seconds)
                    enemyConfig.fireCooldown = 0;
                    enemyConfig.fireCooldownDuration = 90; // Cooldown after firing (1.5 seconds)
                    enemyConfig.shotsPerBurst = 5;
                    enemyConfig.burstDelay = 5; // Delay between shots in a burst
                    enemyConfig.shotsFired = 0;
                    enemyConfig.targetAngle = 0; // Angle to fire burst
                    break;
                case 'SPLITTER':
                    enemyConfig.speed = 1.5 + Math.random();
                    enemyConfig.health = 100;
                    enemyConfig.maxHealth = 100;
                    enemyConfig.size = 20;
                    enemyConfig.splitterCooldown = 60; // Frames between shots (1.5 seconds)
                    enemyConfig.splitterRange = 300; // How far splitter can shoot
                    break;
            }

            gameState.enemies.push(enemyConfig);
        }

        // Add function to spawn boss
        function spawnBoss() {
            // First, check if there's already a boss - if so, don't spawn another one
            const existingBoss = gameState.enemies.find(enemy => enemy.type === 'BOSS');
            if (existingBoss) {
                gameState.isBossFight = true;
                return; // Already have a boss, don't spawn another
            }
            
            // Boss appears at the top center of the screen
            const x = canvas.width / 2;
            const y = 100;
            
            // Boss config - REDUCED HEALTH AND SHIELD FOR EASIER DAMAGE
            const bossConfig = {
                x,
                y,
                type: 'BOSS',
                speed: 1.2,
                health: 500 + (gameState.currentWave * 50),  // Reduced from 1000 to 500
                maxHealth: 500 + (gameState.currentWave * 50),  // Reduced from 1000 to 500
                size: 60,
                bulletCooldown: 60,
                attackPattern: 0,
                attackTimer: 120,
                shield: 100,  // Reduced from 200 to 100
                phase: 1,
                hitFlash: 0  // Add a hit flash timer for visual feedback
            };
            
            // Announce boss arrival
            showBossAnnouncement();
            
            // Clear all obstacles for a clean arena
            gameState.obstacles = [];
            
            // Also clear any normal enemies to make it a true 1v1 boss fight
            gameState.enemies = gameState.enemies.filter(enemy => enemy.type === 'BOSS');
            
            // If we have no bosses (which we shouldn't after the filter), add the new boss
            if (gameState.enemies.length === 0) {
                gameState.enemies.push(bossConfig);
            }
            
            gameState.isBossFight = true;
            gameState.bossDefeated = false;
        }

        function showBossAnnouncement() {
            // Create a temporary announcement element
            const announcement = document.createElement('div');
            announcement.style.position = 'absolute';
            announcement.style.top = '30%';
            announcement.style.left = '50%';
            announcement.style.transform = 'translate(-50%, -50%)';
            announcement.style.color = '#FF00FF';
            announcement.style.fontSize = '48px';
            announcement.style.fontWeight = 'bold';
            announcement.style.textShadow = '0 0 20px #8B008B';
            announcement.style.zIndex = '100';
            announcement.style.opacity = '0';
            announcement.style.transition = 'opacity 1s ease-in-out';
            announcement.textContent = 'BOSS APPROACHING';
            
            // Add to body
            document.body.appendChild(announcement);
            
            // Animate in
            setTimeout(() => {
                announcement.style.opacity = '1';
            }, 100);
            
            // Remove after a few seconds
            setTimeout(() => {
                announcement.style.opacity = '0';
                setTimeout(() => {
                    document.body.removeChild(announcement);
                }, 1000);
            }, 3000);
        }

        function checkEnemyCollisions(enemy, dist) {
            // Check collision with player
            if (dist < CONSTANTS.PLAYER.BASE_SIZE + enemy.size * 0.5) {
                console.log(`Enemy (${enemy.type}) hit player collision detected!`); // DEBUG
                // If shield is active, reduce shield instead of health
                if (gameState.player.shield > 0) {
                    console.log("Player shield is active for enemy collision."); // DEBUG
                    gameState.player.shield -= 75; // Increased from 50 to be more impactful
                    if (gameState.player.shield < 0) gameState.player.shield = 0;
                    // Play shield hit sound for enemy collision
                    console.log("Attempting to play SHIELD_HIT sound (enemy collision)."); // DEBUG
                    SoundManager.playSound('SHIELD_HIT', 0.7);
                } else {
                    console.log("Player shield is NOT active for enemy collision."); // DEBUG
                    // Different damage based on enemy type
                    let damage = 15; // Normal enemy damage (increased from 10)
                    if (enemy.type === 'FAST') damage = 15; // Fast enemy (increased from 10)
                    if (enemy.type === 'TANK') damage = 40; // Tank enemy (increased from 30)
                    if (enemy.type === 'SHOOTER') damage = 25; // Shooter enemy (increased from 20)
                    if (enemy.type === 'BOMBER') damage = 35; // Bomber enemy (increased from 25)
                    if (enemy.type === 'ELITE') damage = 35; // Elite enemy (increased from 25)
                    if (enemy.type === 'BOSS') damage = 50; // Boss enemy (increased from 35)
                
                    // Reduce damage for early waves
                    if (gameState.currentWave <= 2) {
                        damage = Math.round(damage * 0.7);
                    }
                    
                    // Play player hit sound *before* applying damage
                    console.log("Attempting to play PLAYER_HIT sound (enemy collision)."); // DEBUG
                    SoundManager.playSound('PLAYER_HIT', 0.8);
                    
                    gameState.player.health -= damage;
                    
                    // Check for game over
                    if (gameState.player.health <= 0) {
                        gameState.gameOver = true;
                    }
                }
                
                // Special effect for elite collision
                if (enemy.type === 'ELITE') {
                    // Teleport effect for departure
                    createTeleportEffect(enemy.x, enemy.y);
                    
                    // Teleport to a random position further away from player
                    const angle = Math.random() * Math.PI * 2;
                    const distance = 300 + Math.random() * 100;
                    enemy.x = gameState.player.x + Math.cos(angle) * distance;
                    enemy.y = gameState.player.y + Math.sin(angle) * distance;
                    
                    // Teleport effect for arrival
                    createTeleportEffect(enemy.x, enemy.y);
                    
                    // Counter-attack after being hit (immediate attack)
                    enemy.justTeleported = true;
                    
                    // Don't reset teleport cooldown as aggressively
                    enemy.teleportCooldown = Math.max(60, enemy.teleportCooldown);
                    
                    return false; // Don't destroy elite on collision
                }
                
                // Boss doesn't die from collision, just bounces back
                if (enemy.type === 'BOSS') {
                    // Bounce effect
                    const angle = Math.atan2(
                        enemy.y - gameState.player.y,
                        enemy.x - gameState.player.x
                    );
                    enemy.x += Math.cos(angle) * 50;
                    enemy.y += Math.sin(angle) * 50;
                    
                    return false; // Don't destroy boss on collision
                }
                
                // Bomber explodes on collision
                if (enemy.type === 'BOMBER') {
                    // Bomber explosion effect
                    for (let i = 0; i < 30; i++) {
                        gameState.particles.push(createParticle(
                            enemy.x, enemy.y,
                            COLORS.ENEMY.BOMBER.CORE,
                            4, 6, 40,
                            true
                        ));
                    }
                    
                    // Additional damage to player on explosion
                    if (gameState.player.shield > 0) {
                        gameState.player.shield -= 30;
                        if (gameState.player.shield < 0) gameState.player.shield = 0;
                    } else {
                        gameState.player.health -= 20;
                        if (gameState.player.health <= 0) {
                            gameState.gameOver = true;
                        }
                    }
                    
                    return true; // Destroy bomber on collision
                }
                
                // Default explosion for normal enemies
                for (let i = 0; i < 15; i++) {
                    gameState.particles.push(createParticle(
                        enemy.x, enemy.y,
                        COLORS.ENEMY[enemy.type] ? COLORS.ENEMY[enemy.type].CORE : 'red',
                        3, 4, 30,
                        true
                    ));
                }
                
                // Only increase score, but don't count as defeated enemy
                gameState.player.score += 10;
                // Removed: gameState.enemiesDefeated++;
                // checkWaveComplete() is called elsewhere when enemies are defeated properly
                
                return true; // Destroy normal enemy on collision
            }
            
            // For non-boss enemies, continue using the existing collision system
            if (enemy.type !== 'BOSS') {
                // Check collision with player bullets
                let isHit = false;
                gameState.player.bullets = gameState.player.bullets.filter(bullet => {
                    const dx = bullet.x - enemy.x;
                    const dy = bullet.y - enemy.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < CONSTANTS.BULLET.SIZE + enemy.size) {
                        // Calculate damage based on bullet properties and player level
                        let damage = 40 * gameState.player.level.damage; // Increased from 20 to 40 to two-shot normal enemies
                        
                        // If enemy has a shield, reduce that first
                        if (enemy.shield && enemy.shield > 0) {
                            enemy.shield -= damage;
                            // Show shield damage in cyan
                            addFloatingText(enemy.x, enemy.y - enemy.size, Math.round(damage).toString(), '#00FFFF');
                            if (enemy.shield < 0) {
                                // Apply remaining damage to health
                                let healthDamage = -enemy.shield;
                                enemy.health += enemy.shield;
                                enemy.shield = 0;
                                // Show health damage in red
                                addFloatingText(enemy.x, enemy.y - enemy.size + 20, Math.round(healthDamage).toString(), '#FF0000');
                            }
                        } else {
                            // Apply damage directly to health
                            enemy.health -= damage;
                            // Show health damage in red
                            addFloatingText(enemy.x, enemy.y - enemy.size, Math.round(damage).toString(), '#FF0000');
                        }
                        
                        // Create hit effect
                        for (let i = 0; i < 5; i++) {
                            gameState.particles.push(createParticle(
                                bullet.x, bullet.y,
                                COLORS.BULLET.CORE,
                                2, 3, 15,
                                true
                            ));
                        }
                        
                        // Check if enemy is defeated
                        if (enemy.health <= 0) {
                            // Special explosion effect for Bomber enemies when killed
                            if (enemy.type === 'BOMBER') {
                                // Call explode function for the bomber
                                explodeBomber(enemy);
                            } else {
                                // Create regular explosion effect for other enemies
                                let particleCount = enemy.type === 'ELITE' || enemy.type === 'TANK' ? 30 : 15;
                                          
                                for (let i = 0; i < particleCount; i++) {
                                    gameState.particles.push(createParticle(
                                        enemy.x, enemy.y,
                                        COLORS.ENEMY[enemy.type] ? COLORS.ENEMY[enemy.type].CORE : 'red',
                                        3, 4, 30,
                                        true
                                    ));
                                }
                            }
                            
                            // Award score based on enemy type
                            let scoreValue = 10;
                            if (enemy.type === 'FAST') scoreValue = 15;
                            if (enemy.type === 'TANK') scoreValue = 25;
                            if (enemy.type === 'SHOOTER') scoreValue = 30;
                            if (enemy.type === 'BOMBER') scoreValue = 35;
                            if (enemy.type === 'ELITE') scoreValue = 50;
                            
                            gameState.player.score += scoreValue;
                            // Restore for bullet collisions
                            gameState.enemiesDefeated++;
                            
                            // Check if wave is complete
                            checkWaveComplete();
                            
                            isHit = true;
                        }
                        
                        return false; // Remove the bullet
                    }
                    return true; // Keep the bullet
                });
                
                return isHit; // Return true if enemy was destroyed
            }
            
            // Boss enemies never get destroyed here (handled in updateBullets)
            return false;
        }

        function createExplosion(x, y, color) {
            for (let i = 0; i < 20; i++) {
                gameState.particles.push(createParticle(
                    x, y,
                    color,
                    4 + Math.random() * 2,
                    3 + Math.random() * 2,
                    30,
                    true
                ));
            }
        }

        function updateParticles() {
                // More aggressive particle management - this is often a major cause of slowdown
                // Limit the number of particles based on how many enemies are on screen
            const maxParticles = 100 + Math.min(gameState.enemies.length * 20, 100);
                if (gameState.particles.length > maxParticles) {
                    // Keep newest particles which are usually more relevant
                    gameState.particles = gameState.particles.slice(-maxParticles);
                }
                
                gameState.particles = gameState.particles.filter(particle => {
                    particle.x += particle.dx;
                    particle.y += particle.dy;
                    particle.lifetime--;
                    particle.alpha = particle.lifetime / 30;
                    
                    // Remove particles that go off-screen to save processing
                    if (particle.x < 0 || particle.x > canvas.width || 
                        particle.y < 0 || particle.y > canvas.height) {
                        return false;
                    }
                    
                    return particle.lifetime > 0;
                });
                
                // Update shockwaves if they exist
                if (gameState.shockwaves && gameState.shockwaves.length > 0) {
                    gameState.shockwaves = gameState.shockwaves.filter(shockwave => {
                        shockwave.radius += (shockwave.maxRadius - shockwave.radius) * 0.2;
                        shockwave.lifetime--;
                        return shockwave.lifetime > 0;
                    });
            }
        }

        function updatePowerUps() {
            // Spawn power-ups
            if (Math.random() < CONSTANTS.POWER_UPS.SPAWN_CHANCE && gameState.powerUps.length < CONSTANTS.POWER_UPS.MAX_COUNT) {
                // Expanded list of power-up types with equal probability
                const powerUpTypes = ['shield', 'multiShot', 'speedBoost', 'rapidFire', 'healthRestore', 'timeWarp'];
                const powerUpType = powerUpTypes[Math.floor(Math.random() * powerUpTypes.length)];
                
                gameState.powerUps.push({
                    x: Math.random() * (canvas.width - 40) + 20,
                    y: Math.random() * (canvas.height - 40) + 20,
                    type: powerUpType,
                    duration: 300
                });
            }

            // Update existing power-ups
            gameState.powerUps = gameState.powerUps.filter(powerUp => {
                // Safety check for invalid power-ups
                if (!powerUp || !powerUp.type) return false;
                
                try {
                    const dx = gameState.player.x - powerUp.x;
                    const dy = gameState.player.y - powerUp.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < CONSTANTS.PLAYER.BASE_SIZE + 20) {
                        // Get the current duration multiplier (default to 1 if undefined)
                        const durationMultiplier = gameState.player.powerUpDurationMultiplier || 1;

                        // Handle different power-up effects
                        switch(powerUp.type) {
                            case 'shield':
                                gameState.player.shield = 100;
                                gameState.activePowerUps.shield.active = true;
                                // Shield duration isn't really timed, it depends on hits.
                                // We'll set a large total for display consistency, but it depletes by damage.
                                gameState.activePowerUps.shield.remaining = 10000; 
                                gameState.activePowerUps.shield.total = 10000;
                                break;
                            case 'multiShot': {
                                const baseDuration = 5000;
                                const duration = baseDuration * durationMultiplier;
                                gameState.player.multiShot = true;
                                gameState.activePowerUps.multiShot.active = true;
                                gameState.activePowerUps.multiShot.remaining = duration;
                                gameState.activePowerUps.multiShot.total = duration;
                                break;
                            }
                            case 'speedBoost': {
                                const baseDuration = 7000;
                                const duration = baseDuration * durationMultiplier;
                                // Reset to base speed first to prevent stacking
                                gameState.player.speed = CONSTANTS.PLAYER.BASE_SPEED;
                                // Apply new boost
                                gameState.player.speed *= 1.5;
                                gameState.player.speedBoostActive = true;
                                gameState.activePowerUps.speedBoost.active = true;
                                gameState.activePowerUps.speedBoost.remaining = duration;
                                gameState.activePowerUps.speedBoost.total = duration;
                                break;
                            }
                            case 'rapidFire': {
                                const baseDuration = 10000;
                                const duration = baseDuration * durationMultiplier;
                                gameState.player.rapidFire = true;
                                gameState.activePowerUps.rapidFire.active = true;
                                gameState.activePowerUps.rapidFire.remaining = duration; 
                                gameState.activePowerUps.rapidFire.total = duration;
                                // Add floating text to explain the new effect
                                addFloatingText(`Unlimited Fire Rate!`, gameState.player.x, gameState.player.y - 30, COLORS.POWER_UPS.RAPID_FIRE, 40);
                                addFloatingText(`Energy Regen +200%`, gameState.player.x, gameState.player.y - 60, COLORS.POWER_UPS.RAPID_FIRE, 40);
                                break;
                            }
                            case 'healthRestore':
                                // Health restore is instant, no duration multiplier needed
                                const healAmount = gameState.player.maxHealth * 0.3;
                                gameState.player.health = Math.min(
                                    gameState.player.maxHealth,
                                    gameState.player.health + healAmount
                                );
                                // Add visual confirmation of healing
                                for (let i = 0; i < 20; i++) {
                                    gameState.particles.push(createParticle(
                                        gameState.player.x, gameState.player.y,
                                        COLORS.POWER_UPS.HEALTH_RESTORE,
                                        3, 5, 30,
                                        true
                                    ));
                                }
                                // Add a temporary health restored indicator
                                gameState.healthRestoredTime = 120; // Show for 2 seconds (60 frames per second)
                                
                                // Add floating text to show amount healed
                                addFloatingText(`+${Math.round(healAmount)} HP`, gameState.player.x, gameState.player.y - 30, COLORS.POWER_UPS.HEALTH_RESTORE, 40);
                                break;
                            case 'timeWarp': {
                                const baseDuration = 5000;
                                const duration = baseDuration * durationMultiplier;
                                // Apply time warp effect to slow down enemies
                                gameState.timeWarpActive = true;
                                // gameState.player.timeWarpActive = true; // REMOVE THIS LINE
                                gameState.activePowerUps.timeWarp.active = true;
                                gameState.activePowerUps.timeWarp.remaining = duration;
                                gameState.activePowerUps.timeWarp.total = duration;
                                break;
                            }
                        }
                        
                        // Play power-up collection sound
                        SoundManager.playSound('POWERUP_COLLECT', 0.6);
                        
                        // Create visual explosion effect for power-up collection
                        let colorKey;
                        switch(powerUp.type) {
                            case 'shield': colorKey = 'SHIELD'; break;
                            case 'multiShot': colorKey = 'MULTI_SHOT'; break;
                            case 'speedBoost': colorKey = 'SPEED_BOOST'; break;
                            case 'rapidFire': colorKey = 'RAPID_FIRE'; break;
                            case 'healthRestore': colorKey = 'HEALTH_RESTORE'; break;
                            case 'timeWarp': colorKey = 'TIME_WARP'; break;
                            default: colorKey = 'SHIELD'; // Fallback color
                        }
                        createExplosion(powerUp.x, powerUp.y, COLORS.POWER_UPS[colorKey]);
                        return false;
                    }
                    return true;
                } catch (e) {
                    // If there's an error with this power-up, remove it
                    console.log("Power-up error:", e);
                    return false;
                }
            });
            
            // Update remaining duration for active power-ups
            for (const type in gameState.activePowerUps) {
                if (gameState.activePowerUps[type].active) {
                    // Only decrease timer if game is not paused
                    if (!gameState.isPaused) { // Use gameState.isPaused
                        gameState.activePowerUps[type].remaining = Math.max(0, gameState.activePowerUps[type].remaining - (1000/60)); // Decrease by ms per frame
                    }
                    
                    // Handle shield separately since it's based on shield value
                    if (type === 'shield') {
                        gameState.activePowerUps.shield.active = gameState.player.shield > 0;
                        gameState.activePowerUps.shield.remaining = gameState.player.shield * 100; // Scale to display
                    }
                    
                    // Ensure rapid fire status is tied to the timer
                    if (type === 'rapidFire') {
                        gameState.player.rapidFire = gameState.activePowerUps.rapidFire.remaining > 0;
                    }
                    
                    // Check if power-up has expired and deactivate
                    if (gameState.activePowerUps[type].remaining <= 0 && type !== 'shield') {
                        gameState.activePowerUps[type].active = false;
                        
                        // Handle specific power-up deactivations
                        switch(type) {
                            case 'multiShot':
                                gameState.player.multiShot = false;
                                break;
                            case 'rapidFire':
                                gameState.player.rapidFire = false;
                                break;
                            case 'speedBoost':
                                gameState.player.speed = CONSTANTS.PLAYER.BASE_SPEED;
                                gameState.player.speedBoostActive = false;
                                break;
                            case 'timeWarp':
                                gameState.timeWarpActive = false;
                                // gameState.player.timeWarpActive = false; // REMOVE THIS LINE
                                break;
                        }
                    }
                }
            }
        }

        function dash() {
            const player = gameState.player;
            // Calculate direction based on WASD keys
            let dx = 0, dy = 0;
            
            // Check for WASD or arrow keys
            if (KeyboardController.isKeyDown('w') || KeyboardController.isKeyDown('arrowup')) dy = -1;
            if (KeyboardController.isKeyDown('s') || KeyboardController.isKeyDown('arrowdown')) dy = 1;
            if (KeyboardController.isKeyDown('a') || KeyboardController.isKeyDown('arrowleft')) dx = -1;
            if (KeyboardController.isKeyDown('d') || KeyboardController.isKeyDown('arrowright')) dx = 1;
            
            // Normalize if moving diagonally
            if (dx !== 0 && dy !== 0) {
                const norm = Math.sqrt(dx * dx + dy * dy);
                dx /= norm;
                dy /= norm;
            }
            
            // If no direction keys pressed, dash toward mouse
            if (dx === 0 && dy === 0) {
                const dirX = gameState.mousePos.x - player.x;
                const dirY = gameState.mousePos.y - player.y;
                
                // Normalize
                const len = Math.sqrt(dirX * dirX + dirY * dirY);
                dx = dirX / len;
                dy = dirY / len;
            }
            
            // Apply dash movement and effects
            player.x += dx * CONSTANTS.PLAYER.DASH_DISTANCE;
            player.y += dy * CONSTANTS.PLAYER.DASH_DISTANCE;
            
            // Keep in bounds
            player.x = Math.max(CONSTANTS.PLAYER.BASE_SIZE, Math.min(canvas.width - CONSTANTS.PLAYER.BASE_SIZE, player.x));
            player.y = Math.max(CONSTANTS.PLAYER.BASE_SIZE, Math.min(canvas.height - CONSTANTS.PLAYER.BASE_SIZE, player.y));
            
            // Set cooldown and consume energy
            player.dashCooldown = CONSTANTS.PLAYER.DASH_COOLDOWN;
            player.energy -= 30;
            
            // Dash effect
            for (let i = 0; i < 15; i++) {
                gameState.particles.push(createParticle(
                    player.x, player.y,
                    COLORS.PLAYER.TRAIL,
                    3, 3, 30,
                    true
                ));
            }
        }
        
        function checkWaveComplete() {
            if (!gameState.waveComplete && gameState.enemiesDefeated >= gameState.enemiesPerWave) {
                    gameState.waveComplete = true;
                    
                // Add a slight delay before showing the menu to prevent UI issues
                setTimeout(() => {
                    // Check if all waves completed
                    if (gameState.currentWave >= gameState.wavesTotal) {
                        gameState.gameWon = true;
                    } else {
                        // Check if it's time for a boss fight (every 5 waves)
                        if (gameState.currentWave % 5 === 0 && !gameState.bossDefeated) {
                            // Remove all obstacles before boss fight
                            gameState.obstacles = [];
                            
                            // Make sure we're not already in a boss fight
                            if (!gameState.isBossFight) {
                                // Start boss fight
                                spawnBoss();
                                gameState.waveComplete = false;  // Continue the wave
                            }
                        } else if (gameState.isBossFight && gameState.bossDefeated) {
                            // Boss was defeated, proceed to next wave
                            gameState.isBossFight = false;
                            gameState.bossDefeated = false;
                            
                            // We'll increment the wave counter in startNextWave, so set a flag
                            gameState.justDefeatedBoss = true;
                            
                            gameState.enemiesDefeated = 0; // Reset enemy counter for the next wave
                            
                            // Reset enemy spawning parameters to ensure enemies will spawn in next wave
                            gameState.waveComplete = false;

                            // Show upgrade menu and pause the game
                            gameState.isPaused = true; // Use gameState.isPaused
                            showUpgradeMenu();
                            } else {
                            // Normal wave complete, show upgrade menu
                            gameState.isPaused = true; // Use gameState.isPaused
                            showUpgradeMenu();
                        }
                    }
                }, 500);
            } else if (gameState.bossDefeated) {
                // Special case for boss defeat - handle directly without requiring enemiesDefeated check
                // Boss was defeated, proceed to next wave
                gameState.waveComplete = true;
                
                // Add a slight delay before showing the menu to prevent UI issues
                setTimeout(() => {
                            gameState.isBossFight = false;
                            gameState.bossDefeated = false;
                            
                    // We'll increment the wave counter in startNextWave, so set a flag
                    gameState.justDefeatedBoss = true;
                    
                    gameState.enemiesDefeated = 0; // Reset enemy counter for the next wave
                    gameState.waveComplete = false; // Reset wave complete flag
                    
                    // Show upgrade menu and pause the game
                    gameState.isPaused = true; // Use gameState.isPaused
                    showUpgradeMenu();
                }, 500);
            }
        }
        
        function showUpgradeMenu() {
            const upgradeMenu = document.getElementById('upgradeMenu');
            const upgradeOptions = document.getElementById('upgradeOptions');
            
            // Make sure we're not already showing the menu
            if (upgradeMenu.style.display === 'block') {
                return;
            }
            
            // Clear previous options
            upgradeOptions.innerHTML = '';
            
            // Create upgrade buttons
            const upgrades = [
                { name: 'Increase Damage (+0.5)', effect: () => { gameState.player.level.damage += 0.5; } },
                { name: 'Increase Speed (+1)', effect: () => { gameState.player.speed += 1; } },
                { name: 'Increase Health (+25)', effect: () => { 
                    gameState.player.maxHealth += 25; 
                    gameState.player.health = gameState.player.maxHealth;
                }},
                { name: 'Increase Energy (+25)', effect: () => { 
                    gameState.player.maxEnergy += 25; 
                    gameState.player.energy = gameState.player.maxEnergy;
                }},
                // Add new upgrade for power-up duration
                { 
                    name: 'Increase Power-up Duration (+20%)', 
                    effect: () => { 
                        // Initialize multiplier if it doesn't exist
                        if (gameState.player.powerUpDurationMultiplier === undefined) {
                            gameState.player.powerUpDurationMultiplier = 1;
                        }
                        gameState.player.powerUpDurationMultiplier += 0.2;
                    }
                }
            ];
            
            upgrades.forEach(upgrade => {
                const button = document.createElement('button');
                button.className = 'upgrade-button';
                button.textContent = upgrade.name;
                button.onclick = () => {
                    upgrade.effect();
                    closeUpgradeMenu();
                    startNextWave();
                };
                upgradeOptions.appendChild(button);
            });
            
            // Add "No Upgrades" button
            const noUpgradeButton = document.createElement('button');
            noUpgradeButton.className = 'upgrade-button';
            noUpgradeButton.style.background = 'linear-gradient(45deg, #4a1a1a, #6a2a2a)';
            noUpgradeButton.style.borderColor = 'rgba(247, 88, 88, 0.5)';
            noUpgradeButton.textContent = 'No Upgrades';
            noUpgradeButton.onclick = () => {
                closeUpgradeMenu();
                startNextWave();
            };
            upgradeOptions.appendChild(noUpgradeButton);
            
            // Show menu
            upgradeMenu.style.display = 'block';
        }
        
        function closeUpgradeMenu() {
            document.getElementById('upgradeMenu').style.display = 'none';
            // Resume the game after upgrade is selected
            gameState.isPaused = false; // Use gameState.isPaused
        }
        
        function startNextWave() {
            // Increment wave if it's not coming from a boss defeat
            // (Since we now use a flag instead of doing it in two places)
            gameState.currentWave++;
            
            // Clear the flag for next time
            gameState.justDefeatedBoss = false;
            
            gameState.enemiesDefeated = 0;
            gameState.waveComplete = false;
            
            // Increase difficulty
            gameState.enemiesPerWave += 5;
            
            // Clear any existing enemies to ensure clean wave transition
            gameState.enemies = [];
        }
        
        function restartGame() {
            // Reset keyboard first to ensure clean state
            resetKeyboardState();
            
            // Reset game state
            gameState = {
                player: {
                    x: canvas.width / 2,
                    y: canvas.height / 2,
                    speed: CONSTANTS.PLAYER.BASE_SPEED,
                    health: CONSTANTS.PLAYER.BASE_HEALTH,
                    maxHealth: CONSTANTS.PLAYER.BASE_HEALTH,
                    score: 0,
                    bullets: [],
                    dashCooldown: 0,
                    shootCooldown: 0,
                    energy: CONSTANTS.PLAYER.BASE_ENERGY,
                    maxEnergy: CONSTANTS.PLAYER.BASE_ENERGY,
                    trail: [],
                    powerUps: [],
                    shield: 0,
                    multiShot: false,
                    rapidFire: false,
                    speedBoostActive: false,
                    timeWarpActive: false,
                    stuckCounter: 0,
                    velocity: { x: 0, y: 0 }, // Ensure velocity is initialized
                    level: {
                        damage: 1,
                        speed: 1,
                        health: 1,
                        energy: 1
                    },
                    powerUpDurationMultiplier: 1, // Reset power-up duration multiplier
                    radialBurstCooldown: 0, // Initialize to prevent undefined errors
                    radialBurstRegenPenalty: 0 // Initialize to prevent undefined errors
                },
                enemies: [],
                powerUps: [],
                obstacles: [],
                currentWave: 1,
                wavesTotal: 10,
                enemiesPerWave: 10,
                enemiesDefeated: 0,
                waveComplete: false,
                gameOver: false,
                gameWon: false,
                particles: [],
                shockwaves: [],
                keys: {},
                mousePos: { x: 0, y: 0 },
                mouseDown: false,
                enemyBullets: [],
                selectedWave: 1,
                gameStarted: true,
                lastKeyPress: {},
                isBossFight: false,
                bossDefeated: false,
                healthRestoredTime: 0,
                floatingTexts: [],
                timeWarpActive: false,
                justDefeatedBoss: false, // Flag to prevent double wave increment
                activePowerUps: {
                    shield: { active: false, remaining: 0, total: 0 },
                    multiShot: { active: false, remaining: 0, total: 5000 },
                    speedBoost: { active: false, remaining: 0, total: 7000 },
                    rapidFire: { active: false, remaining: 0, total: 10000 }, // Set to 10 seconds exactly
                    timeWarp: { active: false, remaining: 0, total: 5000 }
                },
                gameTimer: 0, // Add timer to track gameplay duration
                mines: [], // <<< Add mines array
                isPaused: false // <<< Add pause state here
            };
            
            // Reset error state
            gameState.isPaused = false; // Use gameState.isPaused
            reducedEffects = false;
            lastTime = 0;
            
            // Hide wave selection menu
            document.getElementById('waveSelectMenu').style.display = 'none';
            
            // Close upgrade menu if open
            closeUpgradeMenu();
            
            // Clear any potentially stuck keys
            resetKeyboardState();
        }
        
        // Helper function to reset keyboard state
        function resetKeyboardState() {
            gameState.keys = {};
            gameState.lastKeyPress = {};
            KeyboardController.resetAllKeys();
        }

        function explodeBomber(bomber) {
            // Create large explosion
            const explosionRadius = 150; // Increased from 100 to 150
            
            // Visual effect - bigger explosion
            for (let i = 0; i < 60; i++) { // Increased from 40 to 60
                gameState.particles.push(createParticle(
                    bomber.x, bomber.y,
                    COLORS.ENEMY.BOMBER.CORE,
                    5 + Math.random() * 4, // Larger particles
                    4 + Math.random() * 6, // Larger particles
                    60, // Longer lifetime
                    true
                ));
            }
            
            // Check if player is caught in explosion
            const dx = gameState.player.x - bomber.x;
            const dy = gameState.player.y - bomber.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist < explosionRadius + CONSTANTS.PLAYER.BASE_SIZE) {
                // Calculate damage based on distance from center (more damage closer to center)
                const damageFactor = 1 - (dist / (explosionRadius + CONSTANTS.PLAYER.BASE_SIZE));
                const damage = Math.round(60 * damageFactor); // Increased from 40 to 60 for more impact
                
                // If shield is active, reduce shield instead of health
                if (gameState.player.shield > 0) {
                    gameState.player.shield -= damage * 2.5; // Increased shield damage multiplier
                    if (gameState.player.shield < 0) gameState.player.shield = 0;
                } else {
                    gameState.player.health -= damage;
                    
                    // Check for game over
                    if (gameState.player.health <= 0) {
                        gameState.gameOver = true;
                    }
                }
                
                // Knockback effect - stronger
                const knockbackForce = 15 * damageFactor; // Increased from 10 to 15
                const knockbackAngle = Math.atan2(dy, dx);
                gameState.player.x += Math.cos(knockbackAngle) * knockbackForce;
                gameState.player.y += Math.sin(knockbackAngle) * knockbackForce;
            }
            
            // Check if other enemies are caught in explosion and damage them too
            gameState.enemies.forEach(enemy => {
                if (enemy !== bomber) { // Don't affect the bomber itself
                    const enemyDx = enemy.x - bomber.x;
                    const enemyDy = enemy.y - bomber.y;
                    const enemyDist = Math.sqrt(enemyDx * enemyDx + enemyDy * enemyDy);
                    
                    if (enemyDist < explosionRadius + enemy.size) {
                        // Calculate damage based on distance
                        const enemyDamageFactor = 1 - (enemyDist / (explosionRadius + enemy.size));
                        const enemyDamage = Math.round(30 * enemyDamageFactor);
                        
                        // Apply damage to enemy
                        enemy.health -= enemyDamage;
                        // Show explosion damage in orange
                        addFloatingText(enemy.x, enemy.y - enemy.size, enemyDamage.toString(), '#FFA500');
                        
                        // Apply knockback effect to other enemies
                        const enemyKnockback = 10 * enemyDamageFactor;
                        const enemyKnockbackAngle = Math.atan2(enemyDy, enemyDx);
                        enemy.x += Math.cos(enemyKnockbackAngle) * enemyKnockback;
                        enemy.y += Math.sin(enemyKnockbackAngle) * enemyKnockback;
                    }
                }
            });
            
            // Create shockwave effect
            const shockwave = {
                x: bomber.x,
                y: bomber.y,
                radius: 10,
                maxRadius: explosionRadius,
                lifetime: 25, // Increased from 20 to 25
                color: COLORS.ENEMY.BOMBER.GLOW
            };
            
            gameState.shockwaves = gameState.shockwaves || [];
            gameState.shockwaves.push(shockwave);
        }
        
        function createTeleportEffect(x, y) {
            // Enhanced visual effect for teleportation
            for (let i = 0; i < 30; i++) { // Increased from 20 to 30 particles
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.random() * 40; // Increased from 30 to 40
                
                gameState.particles.push({
                    x: x + Math.cos(angle) * distance,
                    y: y + Math.sin(angle) * distance,
                    dx: Math.cos(angle) * 3, // Faster particles
                    dy: Math.sin(angle) * 3,
                    size: 3 + Math.random() * 3, // Larger particles
                    color: COLORS.ENEMY.ELITE.CORE,
                    lifetime: 25, // Longer lifetime
                    alpha: 1,
                    glow: true
                });
            }
            
            // Add a shockwave effect
            const shockwave = {
                x: x,
                y: y,
                radius: 5,
                maxRadius: 60,
                lifetime: 15,
                color: COLORS.ENEMY.ELITE.GLOW
            };
            
            gameState.shockwaves = gameState.shockwaves || [];
            gameState.shockwaves.push(shockwave);
        }

        function updateObstacles() {
            // Skip obstacle generation during boss fights
            if (gameState.isBossFight) {
                return;
            }
            
            // Existing obstacle update logic with performance optimization
            gameState.obstacles = gameState.obstacles.filter(obstacle => {
                obstacle.lifetime--;
                if (!obstacle.spawnTime) {
                    obstacle.spawnTime = Date.now();
                }
                return obstacle.lifetime > 0;
            });
            
            // Spawn new obstacles if below max count - limit frequency
            if (gameState.obstacles.length < CONSTANTS.OBSTACLES.MAX_COUNT) {
                // Only try to spawn walls with a lower probability to reduce lag
                if (Math.random() < CONSTANTS.OBSTACLES.SPAWN_CHANCE * 0.8) {
                    const obstacleType = CONSTANTS.OBSTACLES.TYPES[Math.floor(Math.random() * CONSTANTS.OBSTACLES.TYPES.length)];
                    const isHorizontal = Math.random() < 0.5;
                    
                    // Improved obstacle placement to prevent overlapping
                    let x, y;
                    let attempts = 0;
                    const maxAttempts = 5; // Reduced from 10 to 5 for performance
                    let validPosition = false;
                    
                    while (!validPosition && attempts < maxAttempts) {
                        x = Math.random() * (canvas.width - (isHorizontal ? CONSTANTS.OBSTACLES.SIZE : CONSTANTS.OBSTACLES.THICKNESS)) + 
                            (isHorizontal ? CONSTANTS.OBSTACLES.SIZE/2 : CONSTANTS.OBSTACLES.THICKNESS/2);
                        y = Math.random() * (canvas.height - (isHorizontal ? CONSTANTS.OBSTACLES.THICKNESS : CONSTANTS.OBSTACLES.SIZE)) + 
                            (isHorizontal ? CONSTANTS.OBSTACLES.THICKNESS/2 : CONSTANTS.OBSTACLES.SIZE/2);
                        
                        // Check distance from player
                        const playerDist = Math.sqrt(
                            Math.pow(x - gameState.player.x, 2) + 
                            Math.pow(y - gameState.player.y, 2)
                        );
                        
                        // Check distance from other obstacles with optimized check
                        const minObstacleDistance = 150;
                        let tooClose = false;
                        
                        // Check only up to 5 recent obstacles for performance
                        const recentObstacles = gameState.obstacles.slice(-5);
                        for (let i = 0; i < recentObstacles.length; i++) {
                            const obs = recentObstacles[i];
                            const dist = Math.sqrt(
                                Math.pow(x - obs.x, 2) + 
                                Math.pow(y - obs.y, 2)
                            );
                            if (dist <= minObstacleDistance) {
                                tooClose = true;
                                break;
                            }
                        }
                        
                        if (playerDist > 200 && !tooClose) {
                            validPosition = true;
                        }
                        
                        attempts++;
                    }
                    
                    if (validPosition) {
                        gameState.obstacles.push({
                            x: x,
                            y: y,
                            type: obstacleType,
                            isHorizontal: isHorizontal,
                            rotation: isHorizontal ? 0 : Math.PI/2,
                            lifetime: CONSTANTS.OBSTACLES.LIFETIME,
                            spawnTime: Date.now()
                        });
                    }
                }
            }

            // Only check most recently added obstacles for collisions
            const activeObstacles = gameState.obstacles.slice(-10);
            
            // Check collisions with player
            activeObstacles.forEach(obstacle => {
                // Player collision
                const playerCollision = checkWallCollision(gameState.player, obstacle, CONSTANTS.PLAYER.BASE_SIZE);
                if (playerCollision) {
                    // Calculate push direction
                    const dx = gameState.player.x - obstacle.x;
                    const dy = gameState.player.y - obstacle.y;
                    const norm = Math.sqrt(dx * dx + dy * dy);
                    
                    if (norm > 0) {
                        // Push player away from wall with smooth movement
                        const pushX = (dx / norm) * 5;
                        const pushY = (dy / norm) * 5;
                        
                        // Apply push while keeping player in bounds
                        gameState.player.x = Math.max(CONSTANTS.PLAYER.BASE_SIZE, 
                            Math.min(canvas.width - CONSTANTS.PLAYER.BASE_SIZE, 
                            gameState.player.x + pushX));
                        gameState.player.y = Math.max(CONSTANTS.PLAYER.BASE_SIZE, 
                            Math.min(canvas.height - CONSTANTS.PLAYER.BASE_SIZE, 
                            gameState.player.y + pushY));
                    }
                }
            });
            
            // Check collisions with enemies - only check enemies near obstacles
            activeObstacles.forEach(obstacle => {
                // Find nearby enemies (within 100 pixels of the obstacle)
                const nearbyEnemies = gameState.enemies.filter(enemy => {
                    const dx = enemy.x - obstacle.x;
                    const dy = enemy.y - obstacle.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    return dist < 100;
                });
                
                // Check collision for each nearby enemy
                nearbyEnemies.forEach(enemy => {
                    if (checkWallCollision(enemy, obstacle, enemy.size)) {
                        // Calculate push direction
                        const dx = enemy.x - obstacle.x;
                        const dy = enemy.y - obstacle.y;
                        const norm = Math.sqrt(dx * dx + dy * dy);
                        
                        if (norm > 0) {
                            // Push enemy away from wall with smooth movement
                            const pushX = (dx / norm) * 3;
                            const pushY = (dy / norm) * 3;
                            
                            // Apply push while keeping enemy in bounds
                            enemy.x = Math.max(enemy.size, 
                                Math.min(canvas.width - enemy.size, 
                                enemy.x + pushX));
                            enemy.y = Math.max(enemy.size, 
                                Math.min(canvas.height - enemy.size, 
                                enemy.y + pushY));
                            
                            // Update wall avoidance direction
                            enemy.wallAvoidance = {
                                x: dx / norm,
                                y: dy / norm
                            };
                        }
                    }
                });
            });
        }

        function drawObstacles() {
            gameState.obstacles.forEach(obstacle => {
                if (!obstacle || !obstacle.type) return; // Skip invalid obstacles
                
                const now = Date.now();
                const age = now - obstacle.spawnTime;
                const maxLifetime = CONSTANTS.OBSTACLES.LIFETIME * 1000; // Convert to ms
                const remainingLifetime = Math.max(0, maxLifetime - age);
                const fadeOutDuration = 500; // 0.5 second fade out

                let fadeOut = 1;
                if (remainingLifetime < fadeOutDuration) {
                    fadeOut = remainingLifetime / fadeOutDuration;
                }

                const glowColor = COLORS.OBSTACLES[obstacle.type]?.GLOW || '#FFFFFF'; // Default white glow
                const coreColor = COLORS.OBSTACLES[obstacle.type]?.CORE || '#888888'; // Default grey core

                // Pulsing glow effect
                const pulse = Math.sin(now / 300 + obstacle.x * 0.1) * 0.2 + 0.8; // Sine wave pulse
                const glowOpacity = 0.4 * pulse * fadeOut; // Base glow opacity with pulse and fade

                ctx.save();
                ctx.translate(obstacle.x, obstacle.y);
                ctx.rotate(obstacle.rotation);

                // Draw Glow
                ctx.shadowColor = glowColor.replace(')', `, ${glowOpacity})`);
                ctx.shadowBlur = 15 * pulse * fadeOut;

                // Core obstacle shape with rounded corners and slight transparency
                const coreOpacity = 0.8 * fadeOut; // Base core opacity with fade
                const coreFill = coreColor.replace(')', `, ${coreOpacity})`); 
                ctx.fillStyle = coreFill;

                const width = obstacle.width || CONSTANTS.OBSTACLES.SIZE;
                const height = obstacle.height || CONSTANTS.OBSTACLES.THICKNESS;
                const cornerRadius = 8; // Add rounded corners

                ctx.beginPath();
                ctx.roundRect(-width / 2, -height / 2, width, height, cornerRadius); 
                ctx.fill();
                
                // Add subtle inner texture/pattern based on type (optional)
                ctx.strokeStyle = glowColor.replace(')', `, ${0.1 * fadeOut})`); // Faint lines
                ctx.lineWidth = 1;
                if (obstacle.type === 'CRYSTAL_WALL') {
                     // Diagonal crystal-like lines
                    for (let i = -width/2; i < width/2; i += 10) {
                        ctx.beginPath();
                        ctx.moveTo(i, -height/2);
                        ctx.lineTo(i + 10, height/2);
                        ctx.stroke();
                    }
                } else if (obstacle.type === 'BARRIER_WALL') {
                    // Horizontal energy lines
                    for (let i = -height/2 + 3; i < height/2; i += 6) {
                        ctx.beginPath();
                        ctx.moveTo(-width/2, i);
                        ctx.lineTo(width/2, i);
                        ctx.stroke();
                    }
                } // Basic WALL has no extra pattern

                ctx.restore();
            });
        }

        // Drawing functions
        function draw() {
            // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
            // Draw in specific order for layering
            drawBackground();
            drawStars();
            drawObstacles();
            drawPowerUps();
            drawEnemies();
            drawPlayer();
            drawBullets();
            drawEnemyBullets();
            drawParticles();
            drawFloatingTexts(); // Draw floating text
            drawUI();
                
                // Draw pause indicator if game is paused
                if (gameState.isPaused && gameState.gameStarted && !gameState.gameOver && !gameState.gameWon) { // Use gameState.isPaused
                        ctx.save();
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        
                        ctx.font = '48px "Orbitron", sans-serif';
                        ctx.fillStyle = '#FFFFFF';
                        ctx.textAlign = 'center';
                        ctx.fillText('PAUSED', canvas.width / 2, canvas.height / 2 - 30);
                        
                        ctx.font = '24px "Orbitron", sans-serif';
                        ctx.fillText('Press L to resume', canvas.width / 2, canvas.height / 2 + 30);
                        ctx.restore();
                }
                
                // Draw game state messages
                if (gameState.gameOver) {
                drawGameOver();
                } else if (gameState.gameWon) {
                drawGameWon();
                }
                
                // Draw the menu when game is not started
                        if (!gameState.gameStarted && !gameState.gameOver && !gameState.gameWon) {
                document.getElementById('waveSelectMenu').style.display = 'flex';
                        } else {
                document.getElementById('waveSelectMenu').style.display = 'none';
            }
        }

        function drawStars() {
            stars.forEach(star => {
                star.y += star.speed;
                if (star.y > canvas.height) {
                    star.y = 0;
                    star.x = Math.random() * canvas.width;
                }
                
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 255, 255, ${star.speed})`;
                ctx.fill();
            });
        }

        function drawParticles() {
                // Safety check for particles (prevent error)
            if (!gameState.particles || !Array.isArray(gameState.particles)) {
                        gameState.particles = [];
                    return;
                }
                
                // Draw batch of particles instead of individually
                const simpleParticles = [];
                const glowParticles = [];
                
                // Split particles into glow and simple for batch processing
                gameState.particles.forEach(particle => {
                    if (particle && particle.glow) {
                        glowParticles.push(particle);
                    } else if (particle) {
                        simpleParticles.push(particle);
                    }
                });
                
                // Draw glow particles (these are more expensive)
                glowParticles.forEach(particle => {
                    try {
                        // Skip invalid particles
                        if (!particle || typeof particle.color !== 'string') return;
                        
                        // Apply reduced effects if needed
                        if (reducedEffects && Math.random() > 0.5) return;
                        
                        // Safely replace color with alpha
                        let colorWithAlpha;
                        try {
                            colorWithAlpha = particle.color.replace(')', `, ${particle.alpha * 0.5})`);
                        } catch (e) {
                            colorWithAlpha = 'rgba(255,255,255,0.5)';
                        }
                        
                    drawGlow(particle.x, particle.y, particle.size * 2, colorWithAlpha);
                        
                        ctx.beginPath();
                    ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                        ctx.fillStyle = particle.color.replace(')', `, ${particle.alpha})`);
                        ctx.fill();
                    } catch (e) {
                        // Silently ignore drawing errors for individual particles
                        console.log("Particle draw error:", e);
                    }
                });
                
                // Draw simple particles in batches for better performance
                if (simpleParticles.length > 0) {
                    try {
                        ctx.beginPath();
                        simpleParticles.forEach(particle => {
                        if (!particle) return;
                            ctx.moveTo(particle.x, particle.y);
                            ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                        });
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                        ctx.fill();
                    } catch (e) {
                        // Skip batch if there's an error
                    console.log("Simple particles batch error:", e);
                    }
            }
        }

        function drawShockwaves() {
            if (!gameState.shockwaves || gameState.shockwaves.length === 0) return;
            
            gameState.shockwaves.forEach(shockwave => {
                const alpha = shockwave.lifetime / 20;
                ctx.beginPath();
                ctx.arc(shockwave.x, shockwave.y, shockwave.radius, 0, Math.PI * 2);
                ctx.strokeStyle = shockwave.color.replace(')', `, ${alpha})`);
                ctx.lineWidth = 3;
                ctx.stroke();
            });
        }

        function drawPowerUps() {
            gameState.powerUps.forEach(powerUp => {
                // Create a mapping between power-up types and color keys
                let colorKey;
                switch(powerUp.type) {
                    case 'shield': colorKey = 'SHIELD'; break;
                    case 'multiShot': colorKey = 'MULTI_SHOT'; break;
                    case 'speedBoost': colorKey = 'SPEED_BOOST'; break;
                    case 'rapidFire': colorKey = 'RAPID_FIRE'; break;
                    case 'healthRestore': colorKey = 'HEALTH_RESTORE'; break;
                    case 'timeWarp': colorKey = 'TIME_WARP'; break;
                    default: colorKey = 'SHIELD'; // Fallback color
                }
                
                // Larger glow effect for better visibility
                drawGlow(powerUp.x, powerUp.y, 40, 
                        COLORS.POWER_UPS[colorKey].replace(')', ', 0.5)'));
                
                // Larger power-up size
                const powerUpSize = 20;
                ctx.beginPath();
                ctx.arc(powerUp.x, powerUp.y, powerUpSize, 0, Math.PI * 2);
                ctx.fillStyle = COLORS.POWER_UPS[colorKey];
                ctx.fill();
                
                // Brighter outline
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 3;
                ctx.stroke();
                
                // Add pulsing animation for better visibility
                const pulseSize = powerUpSize * (1 + 0.2 * Math.sin(Date.now() / 200));
                ctx.beginPath();
                ctx.arc(powerUp.x, powerUp.y, pulseSize, 0, Math.PI * 2);
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.lineWidth = 2;
                ctx.stroke();
            });
        }

        function drawPlayer() {
            const player = gameState.player;
            
            // Draw trail
            player.trail.forEach((pos, i) => {
                const alpha = i / player.trail.length;
                drawGlow(pos.x, pos.y, 20, `rgba(88, 161, 247, ${alpha * 0.2})`);
            });
            
            // Special effect for speed boost: energy field and particles
            if (player.speedBoostActive) {
                ctx.save();
                ctx.translate(player.x, player.y);
                
                const time = Date.now() / 1000;
                const isMoving = Math.abs(player.velocity.x) > 0.1 || Math.abs(player.velocity.y) > 0.1;
                const movementAngle = Math.atan2(player.velocity.y, player.velocity.x);
                
                // Draw expanding energy rings when moving
                if (isMoving) {
                    const ringCount = 3;
                    for (let i = 0; i < ringCount; i++) {
                        const progress = ((time * 2 + i / ringCount) % 1);
                        const size = CONSTANTS.PLAYER.BASE_SIZE * (1 + progress * 1.5);
                        const alpha = 0.7 * (1 - progress);
                        
                        ctx.beginPath();
                        ctx.arc(0, 0, size, 0, Math.PI * 2);
                        ctx.strokeStyle = `rgba(255, 255, 0, ${alpha})`;
                        ctx.lineWidth = 2 * (1 - progress);
                        ctx.stroke();
                    }
                }
                
                // Draw energy field
                const fieldSize = CONSTANTS.PLAYER.BASE_SIZE * 1.2;
                const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, fieldSize);
                gradient.addColorStop(0, 'rgba(255, 255, 0, 0)');
                gradient.addColorStop(0.5, 'rgba(255, 255, 0, 0.1)');
                gradient.addColorStop(0.7, 'rgba(255, 255, 0, 0.2)');
                gradient.addColorStop(1, 'rgba(255, 255, 0, 0)');
                
                ctx.beginPath();
                ctx.arc(0, 0, fieldSize, 0, Math.PI * 2);
                ctx.fillStyle = gradient;
                ctx.fill();
                
                // Draw energy particles
                if (isMoving) {
                    const particleCount = 12;
                    for (let i = 0; i < particleCount; i++) {
                        const angle = movementAngle + (Math.PI * 2 * i / particleCount) + Math.sin(time * 5) * 0.2;
                        const distance = CONSTANTS.PLAYER.BASE_SIZE * (0.8 + Math.sin(time * 10 + i) * 0.2);
                        const x = Math.cos(angle) * distance;
                        const y = Math.sin(angle) * distance;
                        
                        const particleSize = 3 + Math.sin(time * 8 + i * 0.5) * 1;
                        const alpha = 0.6 + Math.sin(time * 6 + i) * 0.4;
                        
                        ctx.beginPath();
                        ctx.arc(x, y, particleSize, 0, Math.PI * 2);
                        ctx.fillStyle = `rgba(255, 255, 0, ${alpha})`;
                        ctx.fill();
                        
                        // Add particle trails
                        const trailLength = 3;
                        for (let j = 1; j <= trailLength; j++) {
                            const trailDistance = distance * (1 - j * 0.2);
                            const trailX = Math.cos(angle) * trailDistance;
                            const trailY = Math.sin(angle) * trailDistance;
                            const trailAlpha = alpha * (1 - j / trailLength);
                            
                            ctx.beginPath();
                            ctx.arc(trailX, trailY, particleSize * (1 - j * 0.2), 0, Math.PI * 2);
                            ctx.fillStyle = `rgba(255, 255, 0, ${trailAlpha})`;
                            ctx.fill();
                        }
                    }
                }
                
                ctx.restore();
            }

            // Draw shield if active
            if (player.shield > 0) {
                // Enhanced shield visual showing full orbiting rings
                const shieldMaxValue = 100; // Maximum shield value
                const numRings = 3; // Total number of shield rings
                const ringThreshold = shieldMaxValue / numRings; // Health per ring
                
                // Calculate how many full rings to show (1, 2, or 3)
                const fullRings = Math.ceil(player.shield / ringThreshold);
                
                // Shield base glow (always visible when shield is active)
                const pulseAmount = 0.1 * Math.sin(Date.now() / 100); // Subtle pulsing
                const baseShieldSize = CONSTANTS.PLAYER.BASE_SIZE + 20;
                const shieldSize = baseShieldSize + pulseAmount * 10;
                drawGlow(player.x, player.y, shieldSize, 'rgba(88, 161, 247, 0.2)');
                
                // Draw orbiting shield rings
                ctx.save();
                ctx.translate(player.x, player.y);
                
                // Base orbit speed - different for each ring
                const baseOrbitSpeed = Date.now() / 2000;
                
                // Draw each ring
                for (let i = 0; i < fullRings; i++) {
                    // Each ring orbits at different speed and direction
                    const orbitSpeed = baseOrbitSpeed * (i % 2 === 0 ? 1 : -1.5);
                    const ringRadius = CONSTANTS.PLAYER.BASE_SIZE + 15 + (i * 10); // Increasing radius for each ring
                    
                    // Save context for this ring
                    ctx.save();
                    
                    // Rotate the entire ring
                    ctx.rotate(orbitSpeed);
                    
                    // Draw full ring
                    ctx.beginPath();
                    ctx.arc(0, 0, ringRadius, 0, Math.PI * 2);
                    
                    // Style the ring
                    ctx.strokeStyle = 'rgba(88, 161, 247, 0.8)';
                    ctx.lineWidth = 4;
                    
                    // Add glow effect
                    ctx.shadowColor = 'rgba(88, 161, 247, 0.6)';
                    ctx.shadowBlur = 10;
                    
                    ctx.stroke();
                    
                    // Add some detail to the ring - small glowing nodes
                    const nodeCount = 6;
                    for (let j = 0; j < nodeCount; j++) {
                        const nodeAngle = (j * Math.PI * 2 / nodeCount);
                        const nodeX = Math.cos(nodeAngle) * ringRadius;
                        const nodeY = Math.sin(nodeAngle) * ringRadius;
                        
                        ctx.beginPath();
                        ctx.arc(nodeX, nodeY, 4, 0, Math.PI * 2);
                        ctx.fillStyle = 'rgba(120, 190, 255, 0.9)';
                        ctx.fill();
                    }
                    
                    // Reset shadow for next ring
                    ctx.shadowBlur = 0;
                    
                    // Restore context
                    ctx.restore();
                }
                
                ctx.restore();
            }

            // Draw player core
            drawGlow(player.x, player.y, CONSTANTS.PLAYER.BASE_SIZE, 
                    COLORS.PLAYER.GLOW.replace(')', ', 0.5)'));
            
            ctx.beginPath();
            ctx.arc(player.x, player.y, CONSTANTS.PLAYER.BASE_SIZE/2, 0, Math.PI * 2);
            const gradient = ctx.createRadialGradient(
                player.x, player.y, 0,
                player.x, player.y, CONSTANTS.PLAYER.BASE_SIZE/2
            );
            gradient.addColorStop(0, COLORS.PLAYER.CORE);
            gradient.addColorStop(1, COLORS.PLAYER.GLOW);
            ctx.fillStyle = gradient;
            ctx.fill();
            
            // ===== POWER-UP VISUAL ACCESSORIES =====
            
            // Rapid Fire accessory - energy flow representing unlimited fire rate and enhanced regeneration
            if (player.rapidFire) {
                const circleCount = 8;
                const radius = CONSTANTS.PLAYER.BASE_SIZE * 1.2;
                const time = Date.now() / 200; // For rotation
                
                ctx.save();
                ctx.translate(player.x, player.y);
                
                for (let i = 0; i < circleCount; i++) {
                    const angle = time + (i * Math.PI * 2 / circleCount);
                    const x = Math.cos(angle) * radius;
                    const y = Math.sin(angle) * radius;
                    
                    const pulseSize = 3 + Math.sin(time * 3 + i) * 1;
                    
                    ctx.beginPath();
                    ctx.arc(x, y, pulseSize, 0, Math.PI * 2);
                    ctx.fillStyle = COLORS.POWER_UPS.RAPID_FIRE;
                    ctx.fill();
                    
                    // Draw a line from each circle toward the player
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(x * 0.7, y * 0.7);
                    ctx.strokeStyle = COLORS.POWER_UPS.RAPID_FIRE + '80'; // Semi-transparent
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
                ctx.restore();
            }
            
            // Time Warp accessory - clock-like hands rotating in reverse
            if (player.timeWarpActive) {
                ctx.save();
                ctx.translate(player.x, player.y);
                
                // Slow counter-clockwise rotation
                const timeHandAngle = -Date.now() / 500;
                const radius = CONSTANTS.PLAYER.BASE_SIZE * 1.3;
                
                // Hour hand
                ctx.rotate(timeHandAngle);
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(0, -radius * 0.5);
                ctx.strokeStyle = COLORS.POWER_UPS.TIME_WARP;
                ctx.lineWidth = 3;
                ctx.stroke();
                
                // Minute hand
                ctx.rotate(timeHandAngle * 12); // Moves 12x faster
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(0, -radius * 0.8);
                ctx.strokeStyle = COLORS.POWER_UPS.TIME_WARP;
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Clock edge
                ctx.resetTransform();
                ctx.translate(player.x, player.y);
                ctx.beginPath();
                ctx.arc(0, 0, radius, 0, Math.PI * 2);
                ctx.strokeStyle = COLORS.POWER_UPS.TIME_WARP + '50'; // Semi-transparent
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]); // Dashed circle
                ctx.stroke();
                ctx.setLineDash([]); // Reset dash
                
                ctx.restore();
            }
            
            // Health Restore accessory - Fortnite-style bandage
            if (gameState.healthRestoredTime > 0) {
                const pulseSize = 1 + 0.2 * Math.sin(gameState.healthRestoredTime / 4);
                const fadeAlpha = Math.min(1, gameState.healthRestoredTime / 60);
                
                ctx.save();
                ctx.translate(player.x, player.y);
                
                // Make bandage float above player
                const floatY = Math.sin(Date.now() / 300) * 5;
                ctx.translate(0, -30 + floatY);
                
                // Draw Fortnite-style bandage (rectangle with rounded corners)
                const bandageWidth = CONSTANTS.PLAYER.BASE_SIZE * pulseSize;
                const bandageHeight = bandageWidth * 0.4;
                
                // Draw bandage body with rounded corners
                ctx.beginPath();
                const radius = bandageHeight * 0.3;
                // Top-left corner
                ctx.moveTo(-bandageWidth/2 + radius, -bandageHeight/2);
                // Top edge and top-right corner
                ctx.lineTo(bandageWidth/2 - radius, -bandageHeight/2);
                ctx.arcTo(bandageWidth/2, -bandageHeight/2, bandageWidth/2, -bandageHeight/2 + radius, radius);
                // Right edge and bottom-right corner
                ctx.lineTo(bandageWidth/2, bandageHeight/2 - radius);
                ctx.arcTo(bandageWidth/2, bandageHeight/2, bandageWidth/2 - radius, bandageHeight/2, radius);
                // Bottom edge and bottom-left corner
                ctx.lineTo(-bandageWidth/2 + radius, bandageHeight/2);
                ctx.arcTo(-bandageWidth/2, bandageHeight/2, -bandageWidth/2, bandageHeight/2 - radius, radius);
                // Left edge and top-left corner
                ctx.lineTo(-bandageWidth/2, -bandageHeight/2 + radius);
                ctx.arcTo(-bandageWidth/2, -bandageHeight/2, -bandageWidth/2 + radius, -bandageHeight/2, radius);
                
                ctx.fillStyle = `rgba(235, 214, 184, ${fadeAlpha})`;
                ctx.fill();
                ctx.strokeStyle = `rgba(201, 174, 145, ${fadeAlpha})`;
                ctx.lineWidth = 1;
                ctx.stroke();
                
                // Draw cross on bandage
                const crossSize = bandageWidth * 0.3;
                ctx.beginPath();
                ctx.moveTo(-crossSize/2, 0);
                ctx.lineTo(crossSize/2, 0);
                ctx.moveTo(0, -crossSize/2);
                ctx.lineTo(0, crossSize/2);
                ctx.strokeStyle = `rgba(188, 74, 60, ${fadeAlpha})`;
                ctx.lineWidth = bandageWidth * 0.07;
                ctx.stroke();
                
                // Add bandage details (stripes)
                ctx.beginPath();
                const stripeWidth = bandageWidth * 0.15;
                const stripeSpacing = bandageWidth * 0.25;
                
                // Draw a few horizontal stripes
                for (let x = -bandageWidth/2 + stripeSpacing; x < bandageWidth/2 - stripeSpacing/2; x += stripeSpacing) {
                    ctx.moveTo(x, -bandageHeight/2 + 2);
                    ctx.lineTo(x, bandageHeight/2 - 2);
                }
                
                ctx.strokeStyle = `rgba(221, 194, 164, ${fadeAlpha})`;
                ctx.lineWidth = 1;
                ctx.stroke();
                
                ctx.restore();
            }
            
            // Draw turret based on whether multishot is active
            const angle = Math.atan2(
                gameState.mousePos.y - player.y,
                gameState.mousePos.x - player.x
            );
            
            // Function to draw a single turret at specified angle
            function drawTurret(angle, alpha = 1.0) {
                // Save context to restore after rotation
                ctx.save();
                
                // Move to player center
                ctx.translate(player.x, player.y);
                ctx.rotate(angle);
                
                // Draw the turret barrel
                ctx.beginPath();
                const turretLength = CONSTANTS.PLAYER.BASE_SIZE * 0.8;
                const turretWidth = CONSTANTS.PLAYER.BASE_SIZE * 0.25;
                ctx.rect(0, -turretWidth/2, turretLength, turretWidth);
                
                // Create turret gradient
                const turretGradient = ctx.createLinearGradient(0, 0, turretLength, 0);
                turretGradient.addColorStop(0, COLORS.PLAYER.CORE);
                let glowColor = COLORS.PLAYER.GLOW;
                // Adjust alpha for secondary turrets if needed
                if (alpha < 1) {
                    glowColor = glowColor.replace(')', `, ${alpha})`).replace('rgb', 'rgba');
                }
                turretGradient.addColorStop(1, glowColor);
                ctx.fillStyle = turretGradient;
                ctx.fill();
                
                // Add a small glow to the turret
                ctx.shadowColor = COLORS.PLAYER.GLOW;
                ctx.shadowBlur = 5;
                ctx.stroke();
                
                // Reset shadow for next drawings
                ctx.shadowBlur = 0;
                
                // Draw turret base (only for main turret or all if preferred)
                if (alpha === 1.0) {
                    ctx.beginPath();
                    ctx.arc(0, 0, CONSTANTS.PLAYER.BASE_SIZE * 0.3, 0, Math.PI * 2);
                    ctx.fillStyle = COLORS.PLAYER.CORE;
                    ctx.fill();
                    ctx.strokeStyle = COLORS.PLAYER.GLOW;
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
                
                // Restore the canvas context
                ctx.restore();
            }
            
            // Draw main turret and additional turrets if multishot is active
            if (player.multiShot) {
                // Draw all turrets with the same pattern as the bullets
                for (let i = -2; i <= 2; i++) {
                    const spreadAngle = angle + i * 0.1;
                    // Main turret is full opacity, secondary turrets slightly transparent
                    const alpha = i === 0 ? 1.0 : 0.7;
                    drawTurret(spreadAngle, alpha);
                }
            } else {
                // Just draw one turret
                drawTurret(angle);
            }

            // Draw player core and effects
            
            // Time warp effect with hourglass
            if (player.timeWarpActive) {
                const time = Date.now() / 1000;
                
                // Draw time distortion rings
                const ringCount = 2;
                for (let i = 0; i < ringCount; i++) {
                    const progress = ((time * 0.5 + i / ringCount) % 1);
                    const size = CONSTANTS.PLAYER.BASE_SIZE * (2 + progress * 2);
                    const alpha = 0.3 * (1 - progress);
                    
                    ctx.beginPath();
                    ctx.arc(player.x, player.y, size, 0, Math.PI * 2);
                    ctx.strokeStyle = `rgba(128, 0, 255, ${alpha})`;
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]); // Dashed line for time effect
                    ctx.stroke();
                    ctx.setLineDash([]); // Reset line dash
                }
                
                // Draw floating hourglass
                const hourglassY = player.y - CONSTANTS.PLAYER.BASE_SIZE * 1.5;
                const hourglassSize = CONSTANTS.PLAYER.BASE_SIZE * 0.8;
                const hourglassFloat = Math.sin(time * 3) * 5;
                const hourglassRotation = Math.sin(time * 2) * 0.1;
                
                ctx.save();
                ctx.translate(player.x, hourglassY + hourglassFloat);
                ctx.rotate(hourglassRotation);
                
                // Draw hourglass outline
                ctx.beginPath();
                ctx.moveTo(-hourglassSize/2, -hourglassSize/2);
                ctx.lineTo(hourglassSize/2, -hourglassSize/2);
                ctx.lineTo(-hourglassSize/2, hourglassSize/2);
                ctx.lineTo(hourglassSize/2, hourglassSize/2);
                ctx.lineTo(-hourglassSize/2, -hourglassSize/2);
                ctx.strokeStyle = 'rgba(128, 0, 255, 0.8)';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Draw sand particles falling
                const particleCount = 8;
                for (let i = 0; i < particleCount; i++) {
                    const particleProgress = ((time * 2 + i / particleCount) % 1);
                    const particleX = (Math.random() - 0.5) * hourglassSize * 0.3;
                    const particleY = -hourglassSize/2 + hourglassSize * particleProgress;
                    
                    ctx.beginPath();
                    ctx.arc(particleX, particleY, 1, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(255, 223, 128, 0.8)'; // Golden sand color
                    ctx.fill();
                }
                
                // Draw sand pile at bottom
                ctx.beginPath();
                ctx.moveTo(-hourglassSize/2, hourglassSize/2);
                ctx.lineTo(0, hourglassSize/4);
                ctx.lineTo(hourglassSize/2, hourglassSize/2);
                ctx.fillStyle = 'rgba(255, 223, 128, 0.4)';
                ctx.fill();
                
                ctx.restore();
                
                // Draw time runes circling the player
                const runeCount = 4;
                const runeRadius = CONSTANTS.PLAYER.BASE_SIZE * 1.3;
                const runeSize = CONSTANTS.PLAYER.BASE_SIZE * 0.3;
                
                for (let i = 0; i < runeCount; i++) {
                    const runeAngle = (time * 1.5) + (i * Math.PI * 2 / runeCount);
                    const runeX = player.x + Math.cos(runeAngle) * runeRadius;
                    const runeY = player.y + Math.sin(runeAngle) * runeRadius;
                    
                    ctx.save();
                    ctx.translate(runeX, runeY);
                    ctx.rotate(runeAngle + Math.PI/2);
                    
                    // Draw rune symbol (simple clock-like symbol)
                    ctx.beginPath();
                    ctx.arc(0, 0, runeSize, 0, Math.PI * 2);
                    ctx.strokeStyle = 'rgba(128, 0, 255, 0.6)';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // Draw clock hands
                    const handLength = runeSize * 0.7;
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(0, -handLength);
                    ctx.strokeStyle = 'rgba(128, 0, 255, 0.8)';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    ctx.restore();
                }
            }
        }

        function drawBullets() {
            gameState.player.bullets.forEach(bullet => {
                drawGlow(bullet.x, bullet.y, CONSTANTS.BULLET.SIZE * 2, 
                        COLORS.BULLET.GLOW.replace(')', ', 0.3)'));
                
                ctx.beginPath();
                ctx.arc(bullet.x, bullet.y, CONSTANTS.BULLET.SIZE/2, 0, Math.PI * 2);
                ctx.fillStyle = COLORS.BULLET.CORE;
                ctx.fill();
            });
        }

        function drawEnemies() {
            gameState.enemies.forEach(enemy => {
                // Skip drawing enemies that are far off-screen to improve performance
                if (enemy.x < -100 || enemy.x > canvas.width + 100 || 
                    enemy.y < -100 || enemy.y > canvas.height + 100) {
                    return;
                }
                
                ctx.save();
                
                // Draw shadow/glow
                if (!reducedEffects) {
                    if (enemy.type === 'BOSS') {
                        // Bigger, more impressive glow for boss
                        // If hit flash is active, use white glow
                        const glowColor = enemy.hitFlash > 0 ? '#FFFFFF' : COLORS.ENEMY.BOSS.GLOW;
                        drawGlow(enemy.x, enemy.y, enemy.size * 1.8, glowColor);
                        
                        // Draw shield if active
                        if (enemy.shield > 0) {
                            ctx.beginPath();
                            ctx.arc(enemy.x, enemy.y, enemy.size * 1.3, 0, Math.PI * 2);
                            ctx.strokeStyle = `rgba(0, 255, 255, ${enemy.shield / 100})`;
                            ctx.lineWidth = 5;
                            ctx.stroke();
                        }
                    } else {
                        // Normal enemy glow
                        const colorSet = COLORS.ENEMY[enemy.type] || COLORS.ENEMY.NORMAL;
                        drawGlow(enemy.x, enemy.y, enemy.size * 1.5, colorSet.GLOW);
                        
                        // Draw elite shield if applicable
                        if (enemy.type === 'ELITE' && enemy.shield > 0) {
                            ctx.beginPath();
                            ctx.arc(enemy.x, enemy.y, enemy.size * 1.2, 0, Math.PI * 2);
                            ctx.strokeStyle = `rgba(255, 215, 0, ${enemy.shield / 100})`;
                            ctx.lineWidth = 3;
                            ctx.stroke();
                        }
                    }
                }
                
                // Draw enemy
                ctx.beginPath();
                
                if (enemy.type === 'BOSS') {
                    // Draw a more complex boss shape
                    // Main body - flash white when hit
                    ctx.beginPath();
                    ctx.arc(enemy.x, enemy.y, enemy.size, 0, Math.PI * 2);
                    ctx.fillStyle = enemy.hitFlash > 0 ? '#FFFFFF' : COLORS.ENEMY.BOSS.CORE;
                    ctx.fill();
                    
                    // Additional details
                    const innerSize = enemy.size * 0.6;
                    ctx.beginPath();
                    ctx.arc(enemy.x, enemy.y, innerSize, 0, Math.PI * 2);
                    ctx.fillStyle = COLORS.ENEMY.BOSS.GLOW;
                    ctx.fill();
                    
                    // "Eye" in the center
                    ctx.beginPath();
                    ctx.arc(enemy.x, enemy.y, enemy.size * 0.3, 0, Math.PI * 2);
                    ctx.fillStyle = '#FFFFFF';
                    ctx.fill();
                    
                    // Boss "wings"
                    ctx.beginPath();
                    ctx.moveTo(enemy.x - enemy.size, enemy.y);
                    ctx.lineTo(enemy.x - enemy.size * 1.5, enemy.y - enemy.size * 0.5);
                    ctx.lineTo(enemy.x - enemy.size * 1.5, enemy.y + enemy.size * 0.5);
                    ctx.closePath();
                    ctx.fillStyle = COLORS.ENEMY.BOSS.CORE;
                    ctx.fill();
                    
                    ctx.beginPath();
                    ctx.moveTo(enemy.x + enemy.size, enemy.y);
                    ctx.lineTo(enemy.x + enemy.size * 1.5, enemy.y - enemy.size * 0.5);
                    ctx.lineTo(enemy.x + enemy.size * 1.5, enemy.y + enemy.size * 0.5);
                    ctx.closePath();
                    ctx.fillStyle = COLORS.ENEMY.BOSS.CORE;
                    ctx.fill();
                } else {
                    // Draw normal enemy (Default circle) - This block now handles HEALER, TURRET, etc.
                    ctx.beginPath(); // Make sure path is reset
                    ctx.arc(enemy.x, enemy.y, enemy.size, 0, Math.PI * 2);
                    const colorSet = COLORS.ENEMY[enemy.type] || COLORS.ENEMY.NORMAL;
                    ctx.fillStyle = colorSet.CORE;
                    ctx.fill();
                }
                
                // Draw health bar for all enemies
                const healthBarWidth = enemy.size * 2;
                const healthBarHeight = 6;
                const healthPercentage = enemy.health / enemy.maxHealth;
                
                ctx.fillStyle = '#333';
                ctx.fillRect(enemy.x - healthBarWidth / 2, enemy.y - enemy.size - 15, healthBarWidth, healthBarHeight);
                
                // Health bar color based on health percentage
                let healthColor;
                if (healthPercentage > 0.6) healthColor = '#00FF00';
                else if (healthPercentage > 0.3) healthColor = '#FFFF00';
                else healthColor = '#FF0000';
                
                ctx.fillStyle = healthColor;
                ctx.fillRect(
                    enemy.x - healthBarWidth / 2,
                    enemy.y - enemy.size - 15,
                    healthBarWidth * healthPercentage,
                    healthBarHeight
                );
                
                // For boss, add a label and more detailed health bar
                if (enemy.type === 'BOSS') {
                    ctx.font = '14px Arial';
                    ctx.fillStyle = '#FFFFFF';
                    ctx.textAlign = 'center';
                    ctx.fillText('BOSS', enemy.x, enemy.y - enemy.size - 25);
                    
                    // Phase indicator
                    ctx.font = '12px Arial';
                    ctx.fillStyle = enemy.phase === 1 ? '#AAAAFF' : '#FF00FF';
                    ctx.fillText(`Phase ${enemy.phase}`, enemy.x, enemy.y - enemy.size - 5);
                }
                
                ctx.restore();
            });
        }

        function drawUI() {
            const margin = 20;
            const barWidth = 200;  // Reduced width for more compact UI
            const barHeight = 10;  // Slightly reduced height for sleeker look
            const cornerRadius = 8;
            const spacing = 10;    // Reduced spacing for more compact UI
            const panelPadding = 12; // Reduced padding
            
            // Main UI Panel with gradient background
            const panelWidth = barWidth + margin * 2;
            const panelHeight = 250; // Increased panel height from 180 to 250
            const gradient = ctx.createLinearGradient(0, 0, 0, panelHeight);
            gradient.addColorStop(0, 'rgba(20, 20, 40, 0.85)');
            gradient.addColorStop(1, 'rgba(10, 10, 30, 0.85)');
            
            // Draw panel with subtle border glow
            ctx.save();
            ctx.shadowColor = 'rgba(88, 161, 247, 0.3)';
            ctx.shadowBlur = 15;
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.roundRect(margin/2, margin/2, panelWidth, panelHeight, cornerRadius);
            ctx.fill();
            ctx.restore();
            
            // Subtle panel border
            ctx.strokeStyle = 'rgba(88, 161, 247, 0.2)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.roundRect(margin/2, margin/2, panelWidth, panelHeight, cornerRadius);
            ctx.stroke();
            
            // Health bar with dynamic glow based on health percentage
            const healthPercent = gameState.player.health / gameState.player.maxHealth;
            const healthGlow = Math.max(0, 0.5 - (1 - healthPercent) * 0.5);
            const healthY = margin + panelPadding + 5; // Adjusted Y position
            
            ctx.save();
            ctx.shadowColor = `rgba(255, ${healthPercent * 255}, ${healthPercent * 255}, ${healthGlow})`;
            ctx.shadowBlur = 10;
            ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
            ctx.font = '13px "Segoe UI"';
            ctx.fillText('HEALTH', margin + panelPadding, healthY + 4);
            ctx.restore();
            
            // Health percentage
            ctx.textAlign = 'right';
            ctx.fillText(`${Math.round(healthPercent * 100)}%`, margin + panelWidth - panelPadding, healthY + 4);
            ctx.textAlign = 'left';
            
            // Change color based on health percentage
            let healthBarColor, healthBarBgColor;
            if (healthPercent > 0.6) {
                healthBarColor = 'rgba(100, 255, 100, 0.9)';
                healthBarBgColor = 'rgba(0, 200, 0, 0.4)';
            } else if (healthPercent > 0.3) {
                healthBarColor = 'rgba(255, 255, 100, 0.9)';
                healthBarBgColor = 'rgba(200, 200, 0, 0.4)';
            } else {
                healthBarColor = 'rgba(255, 100, 100, 0.9)';
                healthBarBgColor = 'rgba(200, 0, 0, 0.4)';
            }
            
            drawBar(margin + panelPadding, healthY + 10, barWidth - panelPadding * 2, barHeight, 
                   healthPercent, 
                   healthBarColor, 
                   healthBarBgColor, 
                   true);
            
            // Energy bar with dynamic glow
            const energyPercent = gameState.player.energy / gameState.player.maxEnergy;
            const energyY = healthY + barHeight + spacing + 12; // Adjusted Y position
            
            ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
            ctx.fillText('ENERGY', margin + panelPadding, energyY + 4);
            
            // Energy percentage
            ctx.textAlign = 'right';
            ctx.fillText(`${Math.round(energyPercent * 100)}%`, margin + panelWidth - panelPadding, energyY + 4);
            ctx.textAlign = 'left';
            
            drawBar(margin + panelPadding, energyY + 10, barWidth - panelPadding * 2, barHeight,
                   energyPercent,
                   'rgba(50, 150, 255, 0.9)', 
                   'rgba(0, 100, 255, 0.4)',
                   true);
            
            // Stats section with modern icons and more compact layout
            const statsY = energyY + barHeight + spacing + 15; // Adjusted Y position
            ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
            ctx.font = '13px "Segoe UI"';
            
            // Two-column layout for stats
            const colWidth = (barWidth - panelPadding * 2) / 2;
            
            // Score with animated star - Column 1
            const starPulse = Math.sin(Date.now() / 300) * 0.1 + 0.9;
            ctx.font = `${14 * starPulse}px "Segoe UI"`;
            ctx.fillStyle = 'rgba(255, 215, 0, 0.9)';
            ctx.fillText('⭐', margin + panelPadding, statsY);
            ctx.font = '13px "Segoe UI"';
            ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
            ctx.fillText(`${gameState.player.score}`, margin + panelPadding + 20, statsY);
            
            // Wave info with wave animation - Column 2
            const waveOffset = Math.sin(Date.now() / 500) * 2;
            ctx.fillStyle = 'rgba(100, 200, 255, 0.9)';
            ctx.fillText('🌊', margin + panelPadding + colWidth, statsY + waveOffset);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
            ctx.fillText(`${gameState.currentWave}/${gameState.wavesTotal}`, margin + panelPadding + colWidth + 20, statsY);
            
            // Enemy count with target animation - Column 1
            const targetPulse = Math.sin(Date.now() / 400) * 0.1 + 0.9;
            ctx.font = `${14 * targetPulse}px "Segoe UI"`;
            ctx.fillStyle = 'rgba(255, 100, 100, 0.9)';
            ctx.fillText('🎯', margin + panelPadding, statsY + spacing + 18);
            ctx.font = '13px "Segoe UI"';
            ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
            ctx.fillText(`${gameState.enemiesDefeated}/${gameState.enemiesPerWave}`, margin + panelPadding + 20, statsY + spacing + 18);
            
            // Controls hint - Column 2
            ctx.fillStyle = 'rgba(180, 180, 255, 0.9)';
            ctx.fillText('⌨️', margin + panelPadding + colWidth, statsY + spacing + 18);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.fillText('P: Pause', margin + panelPadding + colWidth + 20, statsY + spacing + 18); // Corrected hint
            
            // Timer display - Column 1
            const timerPulse = Math.sin(Date.now() / 400) * 0.1 + 0.9;
            ctx.font = `${14 * timerPulse}px "Segoe UI"`;
            ctx.fillStyle = 'rgba(150, 230, 150, 0.9)';
            ctx.fillText('⏱️', margin + panelPadding, statsY + spacing * 2 + 18);
            ctx.font = '13px "Segoe UI"';
            ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
            ctx.fillText(`${formatTime(gameState.gameTimer)}`, margin + panelPadding + 20, statsY + spacing * 2 + 18);

            // --- START ADDED POWER-UP UI --- 
            const powerUpY = statsY + spacing * 3 + 25; // Position below stats
            let currentY = powerUpY;
            const powerUpBarHeight = 6;
            const powerUpIconSize = 16;
            
            ctx.font = '12px "Segoe UI"';
            
            // Power-up display mapping (Name, Icon, Color)
            const powerUpDisplayInfo = {
                shield: { name: 'Shield', icon: '🛡️', color: COLORS.POWER_UPS.SHIELD },
                multiShot: { name: 'Multi-Shot', icon: '💥', color: COLORS.POWER_UPS.MULTI_SHOT },
                speedBoost: { name: 'Speed Boost', icon: '⚡', color: COLORS.POWER_UPS.SPEED_BOOST },
                rapidFire: { name: 'Rapid Fire', icon: '🔥', color: COLORS.POWER_UPS.RAPID_FIRE },
                timeWarp: { name: 'Time Warp', icon: '⏳', color: COLORS.POWER_UPS.TIME_WARP }
                // Note: Health Restore is instant, no UI needed here
            };
            
            for (const type in gameState.activePowerUps) {
                const powerUpState = gameState.activePowerUps[type];
                const displayInfo = powerUpDisplayInfo[type];
                
                if (powerUpState.active && displayInfo) {
                    const remainingPercent = powerUpState.remaining / powerUpState.total;
                    
                    // Draw Icon
                    ctx.font = `${powerUpIconSize}px "Segoe UI"`;
                    ctx.fillText(displayInfo.icon, margin + panelPadding, currentY + powerUpBarHeight);
                    ctx.font = '12px "Segoe UI"'; // Reset font
                    
                    // Draw Name
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    ctx.fillText(displayInfo.name, margin + panelPadding + powerUpIconSize + 5, currentY + powerUpBarHeight);
                    
                    // Draw Duration Bar (offset slightly to the right)
                    const barX = margin + panelPadding + powerUpIconSize + 5; 
                    const barWidthAdjusted = barWidth - panelPadding * 2 - powerUpIconSize - 5;
                    drawBar(barX, currentY + powerUpBarHeight + 5, barWidthAdjusted, powerUpBarHeight, 
                            remainingPercent, 
                            displayInfo.color, 
                            displayInfo.color.replace(')', ', 0.3)') // Lighter background based on main color
                           );
                           
                    currentY += powerUpBarHeight * 2 + spacing; // Move down for next power-up
                }
            }
            // --- END ADDED POWER-UP UI ---

            // Draw enemy counter (Removed, redundant?)
            /*
            ctx.fillStyle = '#fff';
            ctx.font = '14px "Segoe UI"';
            ctx.textAlign = 'left';
            */
            
            // Add game timer display in the top right corner (This was already commented out)
            /*
            ctx.textAlign = 'right';
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 16px "Segoe UI"';
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.font = '18px Segoe UI, Arial';
            ctx.textAlign = 'right';
            // Comment out the top-right timer display
            // ctx.fillText(`Time: ${formatTime(gameState.gameTimer)}`, canvas.width - margin, margin + 20);
            */
            
            // Draw Score (top right, below where timer was)
            ctx.textAlign = 'right'; // Ensure alignment is right
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)'; // Make score visible
            ctx.font = 'bold 20px "Segoe UI"'; // Make score font larger
            ctx.fillText(`${gameState.player.score}`, canvas.width - margin, margin + 20); // Draw score
            ctx.textAlign = 'left'; // Reset alignment for other potential drawing
        }

        function drawBar(x, y, width, height, fillPercent, fillColor, backgroundColor, rounded = false) {
            const radius = rounded ? height/2 : 0;
            
            // Background with subtle gradient
            const bgGradient = ctx.createLinearGradient(x, y, x, y + height);
            bgGradient.addColorStop(0, 'rgba(30, 30, 50, 0.5)');
            bgGradient.addColorStop(1, 'rgba(20, 20, 40, 0.5)');
            
            ctx.beginPath();
            if (rounded) {
                ctx.roundRect(x, y, width, height, radius);
            } else {
                ctx.rect(x, y, width, height);
            }
            ctx.fillStyle = bgGradient;
            ctx.fill();
            
            // Progress bar
            const fillWidth = Math.max(width * fillPercent, radius * 2);
            
            // Progress gradient
            const gradient = ctx.createLinearGradient(x, y, x, y + height);
            gradient.addColorStop(0, fillColor);
            gradient.addColorStop(1, backgroundColor);
            
            ctx.beginPath();
            if (rounded) {
                ctx.roundRect(x, y, fillWidth, height, radius);
            } else {
                ctx.rect(x, y, fillWidth, height);
            }
            ctx.fillStyle = gradient;
            ctx.fill();
            
            // Add subtle shine effect
            const shine = ctx.createLinearGradient(x, y, x, y + height/2);
            shine.addColorStop(0, 'rgba(255, 255, 255, 0.1)');
            shine.addColorStop(1, 'rgba(255, 255, 255, 0)');
            
            ctx.beginPath();
            if (rounded) {
                ctx.roundRect(x, y, fillWidth, height/2, radius);
            } else {
                ctx.rect(x, y, fillWidth, height/2);
            }
            ctx.fillStyle = shine;
            ctx.fill();
        }

        function drawGameOver() {
            drawEndScreen('Game Over', 'red');
        }

        function drawGameWon() {
            drawEndScreen('Victory!', 'gold');
        }

        function drawVictory() {
            drawEndScreen('Victory!', 'gold');
        }

        function drawEndScreen(text, color) {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = color;
            ctx.font = '48px "Segoe UI"';
            ctx.textAlign = 'center';
            ctx.fillText(text, canvas.width/2, canvas.height/2);
            
            ctx.fillStyle = 'white';
            ctx.font = '24px "Segoe UI"';
            ctx.fillText(`Final Score: ${gameState.player.score}`, canvas.width/2, canvas.height/2 + 50);
            ctx.fillText(`Time: ${formatTime(gameState.gameTimer)}`, canvas.width/2, canvas.height/2 + 80);
            ctx.fillText('Press R to restart game', canvas.width/2, canvas.height/2 + 120);
            
            // Ensure the wave selection menu is initialized for when player returns
            initWaveSelectionMenu();
            
            ctx.textAlign = 'left';
        }

        // Game loop with performance optimization
        let lastTime = 0;
        let frameCount = 0;
        let fpsTimer = 0;
        // Remove the old gamePaused variable declaration
        // let gamePaused = false; 
        let reducedEffects = false;
        
        function detectStuckKeys() {
            // Check for stuck keys that might be causing issues
            const now = Date.now();
            
            // List of movement keys to exclude
            const movementKeys = ['w', 'a', 's', 'd', 'arrowup', 'arrowdown', 'arrowleft', 'arrowright'];
            
            // Check if any key has been held down for too long (more than 3 seconds)
            if (gameState.lastKeyPress) {
                for (const key in gameState.lastKeyPress) {
                    // Skip movement keys - we want to allow holding them down
                    if (movementKeys.includes(key.toLowerCase())) continue;
                    
                    if (gameState.keys[key] && now - gameState.lastKeyPress[key] > 3000) {
                        // Reset this potentially stuck key
                        gameState.keys[key] = false;
                        delete gameState.lastKeyPress[key];
                    }
                }
            }
        }

        function gameLoop(timestamp) {
            // Record frame start time for performance monitoring
            const frameStartTime = performance.now();
            
            try {
                // Calculate delta time for smooth animations
                if (!lastTime) lastTime = timestamp;
                let deltaTime = timestamp - lastTime;
                // --- PAUSE CHECK --- 
                // If paused, update lastTime to prevent jump, but skip updates
                if (gameState.isPaused) {
                    deltaTime = 0; // Effectively stop time for updates
                } else {
                    // If not paused, update lastTime normally
                    lastTime = timestamp;
                }
                // --- END PAUSE CHECK ---

                // Update game timer when game is running and NOT paused
                if (gameState.gameStarted && !gameState.isPaused && !gameState.gameOver && !gameState.gameWon) {
                    gameState.gameTimer += deltaTime;
                }
                
                // FPS monitoring (continue monitoring even if paused)
                // ... existing FPS code ...
                
                // Skip frame if running too slow (prevents spiral of death)
                if (!gameState.isPaused && deltaTime > 100) { // Only cap if not paused
                    window.gameLoopId = requestAnimationFrame(gameLoop);
                    return;
                }
                
                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Check for stuck keys much less frequently (only if not paused)
                if (!gameState.isPaused && Math.random() < 0.01) { 
                    safeExecute(detectStuckKeys, "detectStuckKeys");
                    safeExecute(checkForStuckKeys, "checkForStuckKeys");
                }
                
                // Process game logic only if NOT paused AND sounds are ready
                if (!gameState.isPaused && !gameState.gameOver && !gameState.gameWon && gameState.gameStarted && SoundManager.soundsReady) {
                    safeExecute(updateGame, "updateGame", deltaTime); // Pass deltaTime
                } else if (!SoundManager.soundsReady) {
                    // Draw loading indicator if sounds aren't ready yet
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.font = '24px "Segoe UI"';
                    ctx.textAlign = 'center';
                    ctx.fillText('Loading Sounds...', canvas.width / 2, canvas.height / 2);
                    ctx.textAlign = 'left'; // Reset alignment
                }
                
                // --- Draw everything --- 
                // (Always draw, even when paused to show menu)
                safeExecute(drawBackground, "drawBackground");
                safeExecute(drawStars, "drawStars"); // Restore
                safeExecute(drawObstacles, "drawObstacles"); // Restore
                safeExecute(drawPowerUps, "drawPowerUps"); // Restore
                safeExecute(drawEnemies, "drawEnemies"); // Restore
                safeExecute(drawPlayer, "drawPlayer"); // Restore
                safeExecute(drawBullets, "drawBullets"); // Restore
                safeExecute(drawEnemyBullets, "drawEnemyBullets"); // Restore
                safeExecute(drawParticles, "drawParticles"); // Restore
                safeExecute(drawFloatingTexts, "drawFloatingTexts"); // Restore
                safeExecute(drawMines, "drawMines"); // Keep 
                
                // Draw game state messages (always draw)
                if (gameState.gameOver) { // Restore
                    safeExecute(drawGameOver, "drawGameOver"); // Restore
                } else if (gameState.gameWon) { // Restore
                    safeExecute(drawGameWon, "drawGameWon"); // Restore
                }
                
                // Draw the menu when game is not started (Should be handled by gameStarted logic)
                // Removed the direct manipulation of waveSelectMenu display from here
                
                // Draw debug info if enabled (always draw)
                if (debugMode) { // Restore
                    safeExecute(drawDebugInfo, "drawDebugInfo"); // Restore
                }
                // --- End Draw --- 

            } catch (error) {
                // ... existing error handling ...
            }
           
            
            // Loop with a reference we can cancel if needed
            updateMainUIPanel();
            window.gameLoopId = requestAnimationFrame(gameLoop);
        }

        // Handle visibility change to pause game when tab is inactive
        document.addEventListener('visibilitychange', function() {
            if (document.hidden) {
                gameState.isPaused = true; // Use gameState.isPaused
            } else {
                gameState.isPaused = false; // Use gameState.isPaused
                lastTime = 0; // Reset delta time to prevent huge jumps
            }
        });

        // Check for stuck keys
        function checkForStuckKeys() {
            // Only check every few frames - not every single time
            if (Math.random() > 0.1) return; // Only check 10% of the time
            
            let movementKeysPressed = false;
            
            if (KeyboardController.isKeyDown('w') || KeyboardController.isKeyDown('arrowup') || 
                KeyboardController.isKeyDown('s') || KeyboardController.isKeyDown('arrowdown') ||
                KeyboardController.isKeyDown('a') || KeyboardController.isKeyDown('arrowleft') ||
                KeyboardController.isKeyDown('d') || KeyboardController.isKeyDown('arrowright')) {
                movementKeysPressed = true;
            }
            
            // Only check for genuinely stuck keys (not held keys)
            if (movementKeysPressed && gameState.player.trail.length >= 10) {
                // Check if player hasn't moved AT ALL for many frames (at least 10)
                const positions = gameState.player.trail.slice(-10);
                let allSame = true;
                
                for (let i = 1; i < positions.length; i++) {
                    if (positions[i].x !== positions[0].x || positions[i].y !== positions[0].y) {
                        allSame = false;
                        break;
                    }
                }
                
                // Only reset if absolutely stuck (all 10 positions identical)
                if (allSame) {
                    // Player is completely stuck
                    console.log("Detected completely stuck keys - resetting");
                    KeyboardController.resetAllKeys();
                }
            }
        }

        // Start the game with the optimized loop
        requestAnimationFrame(gameLoop);

        // --- Ensure these functions are defined here ---
        function drawEnemyBullets() {
            gameState.enemyBullets.forEach(bullet => {
                ctx.save();
                
                // Draw glow
                if (!reducedEffects) {
                    drawGlow(
                        bullet.x, bullet.y, 
                        bullet.fromBoss ? (bullet.size || 12) * 1.5 : 12, 
                        bullet.fromBoss ? COLORS.ENEMY.BOSS.GLOW : '#8B0000'
                    );
                }
                
                // Draw bullet
                ctx.beginPath();
                ctx.arc(
                    bullet.x, bullet.y, 
                    bullet.fromBoss ? (bullet.size || 12) : 8, 
                    0, Math.PI * 2
                );
                ctx.fillStyle = bullet.fromBoss ? COLORS.ENEMY.BOSS.CORE : '#FF4040';
                ctx.fill();
                
                ctx.restore();
            });
        }

        function drawBackground() {
            // Fill the background
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw stars
            stars.forEach(star => {
                ctx.fillStyle = `rgba(255, 255, 255, ${0.3 + star.size * 0.3})`;
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                ctx.fill();
            });
            
            // Special background effects during boss fight
            if (gameState.isBossFight) {
                // Subtle pulsing background
                const alpha = 0.05 + Math.sin(Date.now() / 1000) * 0.02;
                ctx.fillStyle = `rgba(128, 0, 128, ${alpha})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Add some ambient particles
                if (Math.random() < 0.1) {
                    const x = Math.random() * canvas.width;
                    const y = Math.random() * canvas.height;
                    gameState.particles.push(createParticle(
                        x, y,
                        COLORS.ENEMY.BOSS.CORE,
                        0.5, 2, 60,
                        true
                    ));
                }
            }
        }
        // --- End ensure ---
        function updateStars() {
            // Update star positions to create parallax scrolling effect
            stars.forEach(star => {
                star.y += star.speed;
                
                // Wrap stars around when they go off screen
                if (star.y > canvas.height) {
                    star.y = 0;
                    star.x = Math.random() * canvas.width;
                }
            });
        }

        // Function to add floating text (for damage numbers, healing, etc.)
        function addFloatingText(x, y, text, color = 'red', size = CONSTANTS.FLOATING_TEXT_SIZE) {
            gameState.floatingTexts.push({
                x,
                y,
                text,
                color,
                size,
                startTime: Date.now(),
                alpha: 1,
                scale: 1.5  // Start larger
            });
        }
        
        // Function to update and draw floating text
        function updateFloatingTexts() {
            const currentTime = Date.now();
            gameState.floatingTexts = gameState.floatingTexts.filter(text => {
                const age = currentTime - text.startTime;
                if (age < CONSTANTS.FLOATING_TEXT_DURATION) {
                    text.y -= CONSTANTS.FLOATING_TEXT_SPEED;
                    text.alpha = 1 - (age / CONSTANTS.FLOATING_TEXT_DURATION);
                    text.scale = 1.5 - (0.5 * age / CONSTANTS.FLOATING_TEXT_DURATION); // Shrink over time
                    return true;
                }
                return false;
            });
        }
        
        function drawFloatingTexts() {
            gameState.floatingTexts.forEach(text => {
                ctx.save();
                ctx.fillStyle = text.color;
                ctx.globalAlpha = text.alpha;
                ctx.font = `bold ${text.size} Arial`;
                ctx.textAlign = 'center';
                // Add shadow for better visibility
                ctx.shadowColor = 'black';
                ctx.shadowBlur = 4;
                ctx.shadowOffsetX = 2;
                ctx.shadowOffsetY = 2;
                // Scale the text
                ctx.translate(text.x, text.y);
                ctx.scale(text.scale, text.scale);
                ctx.fillText(text.text, 0, 0);
                ctx.restore();
            });
        }

        // Format time from milliseconds to MM:SS format
        function formatTime(milliseconds) {
            const totalSeconds = Math.floor(milliseconds / 1000);
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }
        
        // Debug panel functionality
        document.addEventListener('DOMContentLoaded', function() {
            // Debug button event listener
            const debugBtn = document.getElementById('debugBtn');
            if (debugBtn) {
                debugBtn.addEventListener('click', function() {
                    debugMode = !debugMode;
                    const debugPanel = document.getElementById('debugPanel');
                    if (debugPanel) {
                        debugPanel.style.display = debugMode ? 'block' : 'none';
                    }
                    // No text, just icon
                });
            }
            // Debug panel button event listeners
            const debugClearBtn = document.getElementById('debugClearBtn');
            if (debugClearBtn) {
                debugClearBtn.addEventListener('click', function() {
                    const debugContent = document.getElementById('debugContent');
                    if (debugContent) {
                        debugContent.innerHTML = '';
                    }
                    // Also clear frame time history
                    frameTimeHistory = [];
                });
            }
            // Debug toggle button
            const debugToggleBtn = document.getElementById('debugToggleBtn');
            if (debugToggleBtn) {
                debugToggleBtn.addEventListener('click', function() {
                    // Toggle function execution tracking
                    window.functionExecutionTracker.enabled = !window.functionExecutionTracker.enabled;
                    this.textContent = window.functionExecutionTracker.enabled ? 'Tracking: ON' : 'Toggle Debug';
                });
            }
        });
        
        // Function to draw debug information
        function drawDebugInfo() {
            // Update debug panel content
            const debugContent = document.getElementById('debugContent');
            if (debugContent && debugMode) {
                // Calculate average frame time
                const avgFrameTime = frameTimeHistory.length > 0 ? 
                    frameTimeHistory.reduce((sum, time) => sum + time, 0) / frameTimeHistory.length : 0;
                
                // Calculate FPS
                const fps = avgFrameTime > 0 ? 1000 / avgFrameTime : 0;
                
                // Format debug information
                const debugInfo = {
                    'FPS': fps.toFixed(1),
                    'Frame Time': avgFrameTime.toFixed(2) + ' ms',
                    'Game State': gameState.gameStarted ? 'Started' : 'Not Started',
                    'Paused': gameState.isPaused ? 'Yes' : 'No', // Use gameState.isPaused
                    'Wave': gameState.currentWave + '/' + gameState.wavesTotal,
                    'Enemies': gameState.enemies ? gameState.enemies.length : 0,
                    'Particles': gameState.particles ? gameState.particles.length : 0,
                    'Player Health': gameState.player ? Math.round(gameState.player.health) : 'N/A',
                    'Player Energy': gameState.player ? Math.round(gameState.player.energy) : 'N/A',
                    'Position': gameState.player ? 
                        `(${Math.round(gameState.player.x)}, ${Math.round(gameState.player.y)})` : 'N/A',
                    'Reduced Effects': reducedEffects ? 'Yes' : 'No',
                    'Game Timer': typeof formatTime === 'function' ? formatTime(gameState.gameTimer) : (gameState.gameTimer / 1000).toFixed(1) + 's'
                };
                
                // Clear previous content
                debugContent.innerHTML = '';
                
                // Add each debug item
                for (const [key, value] of Object.entries(debugInfo)) {
                    const item = document.createElement('div');
                    item.className = 'debug-item';
                    item.innerHTML = `<span class="debug-key">${key}:</span> <span class="debug-value">${value}</span>`;
                    debugContent.appendChild(item);
                }
                
                // List recent errors if any
                if (window.gameErrors && window.gameErrors.length > 0) {
                    const errorsHeader = document.createElement('div');
                    errorsHeader.className = 'debug-section-header';
                    errorsHeader.textContent = 'Recent Errors:';
                    debugContent.appendChild(errorsHeader);
                    
                    // Show last 3 errors
                    const recentErrors = window.gameErrors.slice(-3);
                    recentErrors.forEach(err => {
                        const errorItem = document.createElement('div');
                        errorItem.className = 'error-entry';
                        errorItem.innerHTML = `
                            <div class="error-message">${err.message}</div>
                            <div class="error-location">${err.location || 'Unknown'}</div>
                            <div class="timestamp">${new Date(err.timestamp).toLocaleTimeString()}</div>
                        `;
                        debugContent.appendChild(errorItem);
                    });
                }
            }
            
            // On-screen debug overlay (simpler version)
            if (debugMode) {
                ctx.save();
                
                // Draw semi-transparent background
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(10, 10, 200, 80);
                
                // Draw basic info
                ctx.font = '14px monospace';
                ctx.fillStyle = 'white';
                
                // Safely calculate FPS
                let fpsText = "FPS: calculating...";
                if (frameTimeHistory && frameTimeHistory.length > 0) {
                    const avgFrameTime = frameTimeHistory.reduce((a, b) => a + b, 0) / frameTimeHistory.length;
                    if (avgFrameTime > 0) {
                        const fps = 1000 / avgFrameTime;
                        fpsText = `FPS: ${fps.toFixed(1)}`;
                    }
                }
                
                ctx.fillText(fpsText, 20, 30);
                ctx.fillText(`Enemies: ${gameState.enemies ? gameState.enemies.length : 0}`, 20, 50);
                ctx.fillText(`Particles: ${gameState.particles ? gameState.particles.length : 0}`, 20, 70);
                
                ctx.restore();
            }
        }
        
        // Helper functions for error tracking
        // Initialize error tracking array
        window.gameErrors = [];
        
        // Enhanced error tracking that also records errors to the debug panel
        function recordError(message, error, location) {
            // Create error record
            const errorRecord = {
                message: message,
                error: error,
                location: location || (error && error.stack ? error.stack.split('\n')[1] : 'Unknown'),
                            timestamp: Date.now()
            };
            
            // Add to errors array
            if (!window.gameErrors) window.gameErrors = [];
            window.gameErrors.push(errorRecord);
            
            // Keep error list at reasonable size
            if (window.gameErrors.length > 20) {
                window.gameErrors.shift();
            }
            
            // Show in debug panel if visible
            updateDebugErrorList();
            
            // Also show the standard error display
            showError(message, error);
        }
        
        // Update the debug panel with recent errors
        function updateDebugErrorList() {
            if (!debugMode) return;
            
            const debugContent = document.getElementById('debugContent');
            if (!debugContent) return;
            
            // Find or create errors section
            let errorsSection = debugContent.querySelector('.debug-errors');
            if (!errorsSection) {
                errorsSection = document.createElement('div');
                errorsSection.className = 'debug-errors';
                debugContent.appendChild(errorsSection);
            }
            
            // Clear and rebuild errors list
            errorsSection.innerHTML = '<h3>Recent Errors</h3>';
            
            // Add recent errors (most recent first)
            const recentErrors = [...window.gameErrors].reverse().slice(0, 5);
            if (recentErrors.length === 0) {
                const noErrors = document.createElement('div');
                noErrors.className = 'no-errors';
                noErrors.textContent = 'No errors recorded';
                errorsSection.appendChild(noErrors);
                        } else {
                recentErrors.forEach(err => {
                    const errorItem = document.createElement('div');
                    errorItem.className = 'error-item';
                    errorItem.innerHTML = `
                        <div class="error-time">${new Date(err.timestamp).toLocaleTimeString()}</div>
                        <div class="error-msg">${err.message}</div>
                        <div class="error-loc">${err.location}</div>
                    `;
                    errorsSection.appendChild(errorItem);
                });
            }
        }

        // Handle visibility change to pause game when tab is inactive
        function updateMainUIPanel() {
    const panel = document.getElementById('mainUIPanel');
    if (!panel) return;
    const healthPercent = Math.max(0, Math.min(1, gameState.player.health / gameState.player.maxHealth));
    const energyPercent = Math.max(0, Math.min(1, gameState.player.energy / gameState.player.maxEnergy));
    const score = gameState.player.score;
    const wave = gameState.currentWave;
    const wavesTotal = gameState.wavesTotal;
    const enemiesDefeated = gameState.enemiesDefeated;
    const enemiesPerWave = gameState.enemiesPerWave;
    const timer = typeof formatTime === 'function' ? formatTime(gameState.gameTimer) : (gameState.gameTimer / 1000).toFixed(1) + 's';
    // Power-ups
    const powerUps = Object.entries(gameState.activePowerUps)
        .filter(([type, state]) => state.active && state.total > 0)
        .map(([type, state]) => {
            let icon = '✨';
            let label = type.charAt(0).toUpperCase() + type.slice(1);
            if (type === 'shield') { icon = '🛡️'; label = 'Shield'; }
            if (type === 'multiShot') { icon = '💥'; label = 'Multi-Shot'; }
            if (type === 'speedBoost') { icon = '⚡'; label = 'Speed'; }
            if (type === 'rapidFire') { icon = '🔥'; label = 'Rapid'; }
            if (type === 'timeWarp') { icon = '⏳'; label = 'Time'; }
            const percent = Math.max(0, Math.min(1, state.remaining / state.total));
            return `<div class='main-ui-powerup-pill'>${icon} ${label}
                <div class='main-ui-powerup-pill-bar'><div class='main-ui-powerup-pill-bar-fill' style='width:${percent*100}%'></div></div>
            </div>`;
        }).join('');
    panel.innerHTML = `
        <div class='main-ui-bar health'>
            <div class='main-ui-bar-fill health' style='width:${healthPercent*100}%'></div>
            <div class='main-ui-bar-value'>${Math.round(healthPercent*100)}%</div>
        </div>
        <div class='main-ui-bar energy'>
            <div class='main-ui-bar-fill energy' style='width:${energyPercent*100}%'></div>
            <div class='main-ui-bar-value'>${Math.round(energyPercent*100)}%</div>
        </div>
        <div class='main-ui-row'>
            <span class='main-ui-icon'>⭐</span><span class='main-ui-value'>${score}</span>
            <span class='main-ui-icon'>🌊</span><span class='main-ui-value'>${wave}/${wavesTotal}</span>
            <span class='main-ui-icon'>🎯</span><span class='main-ui-value'>${enemiesDefeated}/${enemiesPerWave}</span>
        </div>
        <div class='main-ui-timer'>⏱️ ${timer}</div>
        <div class='main-ui-powerups'>${powerUps}</div>
    `;
}

        // Add this function near the other ability functions:
        function shootRadialBurst() {
            const player = gameState.player;
            const bulletCount = 32;
            for (let i = 0; i < bulletCount; i++) {
                const angle = (Math.PI * 2 * i) / bulletCount;
                player.bullets.push({
                    x: player.x,
                    y: player.y,
                    dx: Math.cos(angle) * CONSTANTS.BULLET.SPEED,
                    dy: Math.sin(angle) * CONSTANTS.BULLET.SPEED,
                    lifetime: CONSTANTS.BULLET.LIFETIME
                });
            }
            player.energy = 0;
            player.radialBurstCooldown = 60; // 1 second at 60fps
            SoundManager.playSound('SHOOT', 0.8); // Louder burst sound
            // Visual effect: big flash
            for (let i = 0; i < 24; i++) {
                gameState.particles.push(createParticle(
                    player.x, player.y,
                    COLORS.BULLET.CORE,
                    4, 8, 40,
                    true
                ));
            }
            // In shootRadialBurst(), after setting cooldown:
            player.radialBurstRegenPenalty = 180; // 3 seconds at 60fps
        }
    </script>
</body>
</html> 